import { wrap } from 'comlink';
import { ViewKey, Address, PrivateKeyCiphertext, PrivateKey, RecordCiphertext, Program, Transaction, ProvingKey, VerifyingKey, ProgramManager as ProgramManager$1, RecordPlaintext, verifyFunctionExecution } from '@aleohq/wasm';
export { Address, ExecutionResponse, Field, Execution as FunctionExecution, OfflineQuery, PrivateKey, PrivateKeyCiphertext, Program, ProgramManager as ProgramManagerBase, ProvingKey, RecordCiphertext, RecordPlaintext, Signature, Transaction, VerifyingKey, ViewKey, initThreadPool, verifyFunctionExecution } from '@aleohq/wasm';

/**
 * Key Management class. Enables the creation of a new Aleo Account, importation of an existing account from
 * an existing private key or seed, and message signing and verification functionality.
 *
 * An Aleo Account is generated from a randomly generated seed (number) from which an account private key, view key,
 * and a public account address are derived. The private key lies at the root of an Aleo account. It is a highly
 * sensitive secret and should be protected as it allows for creation of Aleo Program executions and arbitrary value
 * transfers. The View Key allows for decryption of a user's activity on the blockchain. The Address is the public
 * address to which other users of Aleo can send Aleo credits and other records to. This class should only be used
 * environments where the safety of the underlying key material can be assured.
 *
 * @example
 * // Create a new account
 * const myRandomAccount = new Account();
 *
 * // Create an account from a randomly generated seed
 * const seed = new Uint8Array([94, 91, 52, 251, 240, 230, 226, 35, 117, 253, 224, 210, 175, 13, 205, 120, 155, 214, 7, 169, 66, 62, 206, 50, 188, 40, 29, 122, 40, 250, 54, 18]);
 * const mySeededAccount = new Account({seed: seed});
 *
 * // Create an account from an existing private key
 * const myExistingAccount = new Account({privateKey: 'myExistingPrivateKey'})
 *
 * // Sign a message
 * const hello_world = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])
 * const signature = myRandomAccount.sign(hello_world)
 *
 * // Verify a signature
 * myRandomAccount.verify(hello_world, signature)
 */
class Account {
    _privateKey;
    _viewKey;
    _address;
    constructor(params = {}) {
        try {
            this._privateKey = this.privateKeyFromParams(params);
        }
        catch (e) {
            console.error("Wrong parameter", e);
            throw new Error("Wrong Parameter");
        }
        this._viewKey = ViewKey.from_private_key(this._privateKey);
        this._address = Address.from_private_key(this._privateKey);
    }
    /**
     * Attempts to create an account from a private key ciphertext
     * @param {PrivateKeyCiphertext | string} ciphertext
     * @param {string} password
     * @returns {PrivateKey | Error}
     *
     * @example
     * const ciphertext = PrivateKey.newEncrypted("password");
     * const account = Account.fromCiphertext(ciphertext, "password");
     */
    static fromCiphertext(ciphertext, password) {
        try {
            ciphertext = (typeof ciphertext === "string") ? PrivateKeyCiphertext.fromString(ciphertext) : ciphertext;
            const _privateKey = PrivateKey.fromPrivateKeyCiphertext(ciphertext, password);
            return new Account({ privateKey: _privateKey.to_string() });
        }
        catch (e) {
            throw new Error("Wrong password or invalid ciphertext");
        }
    }
    privateKeyFromParams(params) {
        if (params.seed) {
            return PrivateKey.from_seed_unchecked(params.seed);
        }
        if (params.privateKey) {
            return PrivateKey.from_string(params.privateKey);
        }
        return new PrivateKey();
    }
    privateKey() {
        return this._privateKey;
    }
    viewKey() {
        return this._viewKey;
    }
    address() {
        return this._address;
    }
    toString() {
        return this.address().to_string();
    }
    /**
     * Encrypt the account's private key with a password
     * @param {string} ciphertext
     * @returns {PrivateKeyCiphertext}
     *
     * @example
     * const account = new Account();
     * const ciphertext = account.encryptAccount("password");
     */
    encryptAccount(password) {
        return this._privateKey.toCiphertext(password);
    }
    /**
     * Decrypts a Record in ciphertext form into plaintext
     * @param {string} ciphertext
     * @returns {Record}
     *
     * @example
     * const account = new Account();
     * const record = account.decryptRecord("record1ciphertext");
     */
    decryptRecord(ciphertext) {
        return this._viewKey.decrypt(ciphertext);
    }
    /**
     * Decrypts an array of Records in ciphertext form into plaintext
     * @param {string[]} ciphertexts
     * @returns {Record[]}
     *
     * @example
     * const account = new Account();
     * const record = account.decryptRecords(["record1ciphertext", "record2ciphertext"]);
     */
    decryptRecords(ciphertexts) {
        return ciphertexts.map((ciphertext) => this._viewKey.decrypt(ciphertext));
    }
    /**
     * Determines whether the account owns a ciphertext record
     * @param {RecordCipherText | string} ciphertext
     * @returns {boolean}
     *
     * @example
     * // Create a connection to the Aleo network and an account
     * const connection = new NodeConnection("vm.aleo.org/api");
     * const account = Account.fromCiphertext("ciphertext", "password");
     *
     * // Get a record from the network
     * const record = connection.getBlock(1234);
     * const recordCipherText = record.transactions[0].execution.transitions[0].id;
     *
     * // Check if the account owns the record
     * if account.ownsRecord(recordCipherText) {
     *     // Then one can do something like:
     *     // Decrypt the record and check if it's spent
     *     // Store the record in a local database
     *     // Etc.
     * }
     */
    ownsRecordCiphertext(ciphertext) {
        if (typeof ciphertext === 'string') {
            try {
                const ciphertextObject = RecordCiphertext.fromString(ciphertext);
                return ciphertextObject.isOwner(this._viewKey);
            }
            catch (e) {
                return false;
            }
        }
        else {
            return ciphertext.isOwner(this._viewKey);
        }
    }
    /**
     * Signs a message with the account's private key.
     * Returns a Signature.
     *
     * @param {Uint8Array} message
     * @returns {Signature}
     *
     * @example
     * const account = new Account();
     * const message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])
     * account.sign(message);
     */
    sign(message) {
        return this._privateKey.sign(message);
    }
    /**
     * Verifies the Signature on a message.
     *
     * @param {Uint8Array} message
     * @param {Signature} signature
     * @returns {boolean}
     *
     * @example
     * const account = new Account();
     * const message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])
     * const signature = account.sign(message);
     * account.verify(message, signature);
     */
    verify(message, signature) {
        return this._address.verify(message, signature);
    }
}

async function get(url) {
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(response.status + " could not get URL " + url);
    }
    return response;
}
async function post(url, options) {
    options.method = "POST";
    const response = await fetch(url, options);
    if (!response.ok) {
        throw new Error(response.status + " could not post URL " + url);
    }
    return response;
}

/**
 * Client library that encapsulates REST calls to publicly exposed endpoints of Aleo nodes. The methods provided in this
 * allow users to query public information from the Aleo blockchain and submit transactions to the network.
 *
 * @param {string} host
 * @example
 * // Connection to a local node
 * const localNetworkClient = new AleoNetworkClient("http://localhost:3030");
 *
 * // Connection to a public beacon node
 * const publicnetworkClient = new AleoNetworkClient("https://api.explorer.aleo.org/v1");
 */
class AleoNetworkClient {
    host;
    account;
    constructor(host) {
        this.host = host + "/testnet3";
    }
    /**
     * Set an account to use in networkClient calls
     *
     * @param {Account} account
     * @example
     * const account = new Account();
     * networkClient.setAccount(account);
     */
    setAccount(account) {
        this.account = account;
    }
    /**
     * Return the Aleo account used in the networkClient
     *
     * @example
     * const account = networkClient.getAccount();
     */
    getAccount() {
        return this.account;
    }
    /**
     * Set a new host for the networkClient
     *
     * @param {string} host The address of a node hosting the Aleo API
     * @param host
     */
    setHost(host) {
        this.host = host + "/testnet3";
    }
    async fetchData(url = "/") {
        try {
            const response = await get(this.host + url);
            return await response.json();
        }
        catch (error) {
            throw new Error("Error fetching data.");
        }
    }
    /**
     * Attempts to find unspent records in the Aleo blockchain for a specified private key
     * @param {number} startHeight - The height at which to start searching for unspent records
     * @param {number} endHeight - The height at which to stop searching for unspent records
     * @param {string | PrivateKey} privateKey - The private key to use to find unspent records
     * @param {number[]} amounts - The amounts (in microcredits) to search for (eg. [100, 200, 3000])
     * @param {number} maxMicrocredits - The maximum number of microcredits to search for
     * @param {string[]} nonces - The nonces of already found records to exclude from the search
     *
     * @example
     * // Find all unspent records
     * const privateKey = "[PRIVATE_KEY]";
     * const records = networkClient.findUnspentRecords(0, undefined, privateKey);
     *
     * // Find specific amounts
     * const startHeight = 500000;
     * const amounts = [600000, 1000000];
     * const records = networkClient.findUnspentRecords(startHeight, undefined, privateKey, amounts);
     *
     * // Find specific amounts with a maximum number of cumulative microcredits
     * const maxMicrocredits = 100000;
     * const records = networkClient.findUnspentRecords(startHeight, undefined, privateKey, undefined, maxMicrocredits);
     */
    async findUnspentRecords(startHeight, endHeight, privateKey, amounts, maxMicrocredits, nonces) {
        nonces = nonces || [];
        // Ensure start height is not negative
        if (startHeight < 0) {
            throw new Error("Start height must be greater than or equal to 0");
        }
        // Initialize search parameters
        const records = new Array();
        let start;
        let end;
        let resolvedPrivateKey;
        let failures = 0;
        let totalRecordValue = BigInt(0);
        let latestHeight;
        // Ensure a private key is present to find owned records
        if (typeof privateKey === "undefined") {
            if (typeof this.account === "undefined") {
                throw new Error("Private key must be specified in an argument to findOwnedRecords or set in the AleoNetworkClient");
            }
            else {
                resolvedPrivateKey = this.account._privateKey;
            }
        }
        else {
            try {
                resolvedPrivateKey = privateKey instanceof PrivateKey ? privateKey : PrivateKey.from_string(privateKey);
            }
            catch (error) {
                throw new Error("Error parsing private key provided.");
            }
        }
        const viewKey = resolvedPrivateKey.to_view_key();
        // Get the latest height to ensure the range being searched is valid
        try {
            const blockHeight = await this.getLatestHeight();
            if (typeof blockHeight === "number") {
                latestHeight = blockHeight;
            }
            else {
                throw new Error("Error fetching latest block height.");
            }
        }
        catch (error) {
            throw new Error("Error fetching latest block height.");
        }
        // If no end height is specified or is greater than the latest height, set the end height to the latest height
        if (typeof endHeight === "number" && endHeight <= latestHeight) {
            end = endHeight;
        }
        else {
            end = latestHeight;
        }
        // If the starting is greater than the ending height, return an error
        if (startHeight > end) {
            throw new Error("Start height must be less than or equal to end height.");
        }
        // Iterate through blocks in reverse order in chunks of 50
        while (end > startHeight) {
            start = end - 50;
            if (start < startHeight) {
                start = startHeight;
            }
            try {
                // Get 50 blocks (or the difference between the start and end if less than 50)
                const blocks = await this.getBlockRange(start, end);
                end = start;
                if (!(blocks instanceof Error)) {
                    // Iterate through blocks to find unspent records
                    for (let i = 0; i < blocks.length; i++) {
                        const block = blocks[i];
                        const transactions = block.transactions;
                        if (!(typeof transactions === "undefined")) {
                            for (let j = 0; j < transactions.length; j++) {
                                const confirmedTransaction = transactions[j];
                                // Search for unspent records in execute transactions of credits.aleo
                                if (confirmedTransaction.type == "execute") {
                                    const transaction = confirmedTransaction.transaction;
                                    if (transaction.execution && !(typeof transaction.execution.transitions == "undefined")) {
                                        for (let k = 0; k < transaction.execution.transitions.length; k++) {
                                            const transition = transaction.execution.transitions[k];
                                            // Only search for unspent records in credits.aleo (for now)
                                            if (transition.program !== "credits.aleo") {
                                                continue;
                                            }
                                            if (!(typeof transition.outputs == "undefined")) {
                                                for (let l = 0; l < transition.outputs.length; l++) {
                                                    const output = transition.outputs[l];
                                                    if (output.type === "record") {
                                                        try {
                                                            // Create a wasm record ciphertext object from the found output
                                                            const record = RecordCiphertext.fromString(output.value);
                                                            // Determine if the record is owned by the specified view key
                                                            if (record.isOwner(viewKey)) {
                                                                // Decrypt the record and get the serial number
                                                                const recordPlaintext = record.decrypt(viewKey);
                                                                // If the record has already been found, skip it
                                                                const nonce = recordPlaintext.nonce();
                                                                if (nonces.includes(nonce)) {
                                                                    continue;
                                                                }
                                                                // Otherwise record the nonce that has been found
                                                                const serialNumber = recordPlaintext.serialNumberString(resolvedPrivateKey, "credits.aleo", "credits");
                                                                // Attempt to see if the serial number is spent
                                                                try {
                                                                    await this.getTransitionId(serialNumber);
                                                                }
                                                                catch (error) {
                                                                    // If it's not found, add it to the list of unspent records
                                                                    if (!amounts) {
                                                                        records.push(recordPlaintext);
                                                                        // If the user specified a maximum number of microcredits, check if the search has found enough
                                                                        if (typeof maxMicrocredits === "number") {
                                                                            totalRecordValue += recordPlaintext.microcredits();
                                                                            // Exit if the search has found the amount specified
                                                                            if (totalRecordValue >= BigInt(maxMicrocredits)) {
                                                                                return records;
                                                                            }
                                                                        }
                                                                    }
                                                                    // If the user specified a list of amounts, check if the search has found them
                                                                    if (!(typeof amounts === "undefined") && amounts.length > 0) {
                                                                        let amounts_found = 0;
                                                                        if (recordPlaintext.microcredits() > amounts[amounts_found]) {
                                                                            amounts_found += 1;
                                                                            records.push(recordPlaintext);
                                                                            // If the user specified a maximum number of microcredits, check if the search has found enough
                                                                            if (typeof maxMicrocredits === "number") {
                                                                                totalRecordValue += recordPlaintext.microcredits();
                                                                                // Exit if the search has found the amount specified
                                                                                if (totalRecordValue >= BigInt(maxMicrocredits)) {
                                                                                    return records;
                                                                                }
                                                                            }
                                                                            if (records.length >= amounts.length) {
                                                                                return records;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        catch (error) {
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (error) {
                // If there is an error fetching blocks, log it and keep searching
                console.warn("Error fetching blocks in range: " + start.toString() + "-" + end.toString());
                console.warn("Error: ", error);
                failures += 1;
                if (failures > 10) {
                    console.warn("10 failures fetching records reached. Returning records fetched so far");
                    return records;
                }
            }
        }
        return records;
    }
    /**
     * Returns the contents of the block at the specified block height
     *
     * @param {number} height
     * @example
     * const block = networkClient.getBlock(1234);
     */
    async getBlock(height) {
        try {
            const block = await this.fetchData("/block/" + height);
            return block;
        }
        catch (error) {
            throw new Error("Error fetching block.");
        }
    }
    /**
     * Returns a range of blocks between the specified block heights
     *
     * @param {number} start
     * @param {number} end
     * @example
     * const blockRange = networkClient.getBlockRange(2050, 2100);
     */
    async getBlockRange(start, end) {
        try {
            return await this.fetchData("/blocks?start=" + start + "&end=" + end);
        }
        catch (error) {
            const errorMessage = "Error fetching blocks between " + start + " and " + end + ".";
            throw new Error(errorMessage);
        }
    }
    /**
     * Returns the deployment transaction id associated with the specified program
     *
     * @param {Program | string} program
     * @returns {TransactionModel | Error}
     */
    async getDeploymentTransactionIDForProgram(program) {
        if (program instanceof Program) {
            program = program.toString();
        }
        try {
            const id = await this.fetchData("/find/transactionID/deployment/" + program);
            return id.replace("\"", "");
        }
        catch (error) {
            throw new Error("Error fetching deployment transaction for program.");
        }
    }
    /**
     * Returns the deployment transaction associated with a specified program
     *
     * @param {Program | string} program
     * @returns {TransactionModel | Error}
     */
    async getDeploymentTransactionForProgram(program) {
        try {
            const transaction_id = await this.getDeploymentTransactionIDForProgram(program);
            return await this.getTransaction(transaction_id);
        }
        catch (error) {
            throw new Error("Error fetching deployment transaction for program.");
        }
    }
    /**
     * Returns the contents of the latest block
     *
     * @example
     * const latestHeight = networkClient.getLatestBlock();
     */
    async getLatestBlock() {
        try {
            return await this.fetchData("/latest/block");
        }
        catch (error) {
            throw new Error("Error fetching latest block.");
        }
    }
    /**
     * Returns the latest committee
     *
     * @returns {Promise<object>} A javascript object containing the latest committee
     */
    async getLatestCommittee() {
        try {
            return await this.fetchData("/committee/latest");
        }
        catch (error) {
            throw new Error("Error fetching latest block.");
        }
    }
    /**
     * Returns the latest block height
     *
     * @example
     * const latestHeight = networkClient.getLatestHeight();
     */
    async getLatestHeight() {
        try {
            return await this.fetchData("/latest/height");
        }
        catch (error) {
            throw new Error("Error fetching latest height.");
        }
    }
    /**
     * Returns the source code of a program given a program ID
     *
     * @param {string} programId The program ID of a program deployed to the Aleo Network
     * @return {Promise<string>} Source code of the program
     *
     * @example
     * const program = networkClient.getProgram("hello_hello.aleo");
     * const expectedSource = "program hello_hello.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n"
     * assert.equal(program, expectedSource);
     */
    async getProgram(programId) {
        try {
            return await this.fetchData("/program/" + programId);
        }
        catch (error) {
            throw new Error("Error fetching program");
        }
    }
    /**
     * Returns a program object from a program ID or program source code
     *
     * @param {string} inputProgram The program ID or program source code of a program deployed to the Aleo Network
     * @return {Promise<Program | Error>} Source code of the program
     *
     * @example
     * const programID = "hello_hello.aleo";
     * const programSource = "program hello_hello.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n"
     *
     * // Get program object from program ID or program source code
     * const programObjectFromID = await networkClient.getProgramObject(programID);
     * const programObjectFromSource = await networkClient.getProgramObject(programSource);
     *
     * // Both program objects should be equal
     * assert.equal(programObjectFromID.to_string(), programObjectFromSource.to_string());
     */
    async getProgramObject(inputProgram) {
        try {
            return Program.fromString(inputProgram);
        }
        catch (error) {
            try {
                return Program.fromString((await this.getProgram(inputProgram)));
            }
            catch (error) {
                throw new Error(`${inputProgram} is neither a program name or a valid program`);
            }
        }
    }
    /**
     *  Returns an object containing the source code of a program and the source code of all programs it imports
     *
     * @param {Program | string} inputProgram The program ID or program source code of a program deployed to the Aleo Network
     * @returns {Promise<ProgramImports>} Object of the form { "program_id": "program_source", .. } containing program id & source code for all program imports
     *
     * @example
     * const double_test_source = "import multiply_test.aleo;\n\nprogram double_test.aleo;\n\nfunction double_it:\n    input r0 as u32.private;\n    call multiply_test.aleo/multiply 2u32 r0 into r1;\n    output r1 as u32.private;\n"
     * const double_test = Program.fromString(double_test_source);
     * const expectedImports = {
     *     "multiply_test.aleo": "program multiply_test.aleo;\n\nfunction multiply:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    mul r0 r1 into r2;\n    output r2 as u32.private;\n"
     * }
     *
     * // Imports can be fetched using the program ID, source code, or program object
     * let programImports = await networkClient.getProgramImports("double_test.aleo");
     * assert.deepStrictEqual(programImports, expectedImports);
     *
     * // Using the program source code
     * programImports = await networkClient.getProgramImports(double_test_source);
     * assert.deepStrictEqual(programImports, expectedImports);
     *
     * // Using the program object
     * programImports = await networkClient.getProgramImports(double_test);
     * assert.deepStrictEqual(programImports, expectedImports);
     */
    async getProgramImports(inputProgram) {
        try {
            const imports = {};
            // Get the program object or fail if the program is not valid or does not exist
            const program = inputProgram instanceof Program ? inputProgram : (await this.getProgramObject(inputProgram));
            // Get the list of programs that the program imports
            const importList = program.getImports();
            // Recursively get any imports that the imported programs have in a depth first search order
            for (let i = 0; i < importList.length; i++) {
                const import_id = importList[i];
                if (!imports.hasOwnProperty(import_id)) {
                    const programSource = await this.getProgram(import_id);
                    const nestedImports = await this.getProgramImports(import_id);
                    for (const key in nestedImports) {
                        if (!imports.hasOwnProperty(key)) {
                            imports[key] = nestedImports[key];
                        }
                    }
                    imports[import_id] = programSource;
                }
            }
            return imports;
        }
        catch (error) {
            throw logAndThrow("Error fetching program imports: " + error);
        }
    }
    /**
     * Get a list of the program names that a program imports
     *
     * @param {Program | string} inputProgram - The program id or program source code to get the imports of
     * @returns {string[]} - The list of program names that the program imports
     *
     * @example
     * const programImportsNames = networkClient.getProgramImports("double_test.aleo");
     * const expectedImportsNames = ["multiply_test.aleo"];
     * assert.deepStrictEqual(programImportsNames, expectedImportsNames);
     */
    async getProgramImportNames(inputProgram) {
        try {
            const program = inputProgram instanceof Program ? inputProgram : (await this.getProgramObject(inputProgram));
            return program.getImports();
        }
        catch (error) {
            throw new Error("Error fetching program imports with error: " + error);
        }
    }
    /**
     * Returns the names of the mappings of a program
     *
     * @param {string} programId - The program ID to get the mappings of (e.g. "credits.aleo")
     * @example
     * const mappings = networkClient.getProgramMappingNames("credits.aleo");
     * const expectedMappings = ["account"];
     * assert.deepStrictEqual(mappings, expectedMappings);
     */
    async getProgramMappingNames(programId) {
        try {
            return await this.fetchData("/program/" + programId + "/mappings");
        }
        catch (error) {
            throw new Error("Error fetching program mappings - ensure the program exists on chain before trying again");
        }
    }
    /**
     * Returns the value of a program's mapping for a specific key
     *
     * @param {string} programId - The program ID to get the mapping value of (e.g. "credits.aleo")
     * @param {string} mappingName - The name of the mapping to get the value of (e.g. "account")
     * @param {string} key - The key of the mapping to get the value of (e.g. "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px")
     * @return {Promise<string>} String representation of the value of the mapping
     *
     * @example
     * // Get public balance of an account
     * const mappingValue = networkClient.getMappingValue("credits.aleo", "account", "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px");
     * const expectedValue = "0u64";
     * assert.equal(mappingValue, expectedValue);
     */
    async getProgramMappingValue(programId, mappingName, key) {
        try {
            return await this.fetchData("/program/" + programId + "/mapping/" + mappingName + "/" + key);
        }
        catch (error) {
            throw new Error("Error fetching mapping value - ensure the mapping exists and the key is correct");
        }
    }
    /**
     * Returns the latest state/merkle root of the Aleo blockchain
     *
     * @example
     * const stateRoot = networkClient.getStateRoot();
     */
    async getStateRoot() {
        try {
            return await this.fetchData("/latest/stateRoot");
        }
        catch (error) {
            throw new Error("Error fetching Aleo state root");
        }
    }
    /**
     * Returns a transaction by its unique identifier
     *
     * @param {string} id
     * @example
     * const transaction = networkClient.getTransaction("at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj");
     */
    async getTransaction(id) {
        try {
            return await this.fetchData("/transaction/" + id);
        }
        catch (error) {
            throw new Error("Error fetching transaction.");
        }
    }
    /**
     * Returns the transactions present at the specified block height
     *
     * @param {number} height
     * @example
     * const transactions = networkClient.getTransactions(654);
     */
    async getTransactions(height) {
        try {
            return await this.fetchData("/block/" + height.toString() + "/transactions");
        }
        catch (error) {
            throw new Error("Error fetching transactions.");
        }
    }
    /**
     * Returns the transactions in the memory pool.
     *
     * @example
     * const transactions = networkClient.getTransactionsInMempool();
     */
    async getTransactionsInMempool() {
        try {
            return await this.fetchData("/memoryPool/transactions");
        }
        catch (error) {
            throw new Error("Error fetching transactions from mempool.");
        }
    }
    /**
     * Returns the transition ID of the transition corresponding to the ID of the input or output.
     * @param {string} inputOrOutputID - ID of the input or output.
     *
     * @example
     * const transitionId = networkClient.getTransitionId("2429232855236830926144356377868449890830704336664550203176918782554219952323field");
     */
    async getTransitionId(inputOrOutputID) {
        try {
            return await this.fetchData("/find/transitionID/" + inputOrOutputID);
        }
        catch (error) {
            throw new Error("Error fetching transition ID.");
        }
    }
    /**
     * Submit an execute or deployment transaction to the Aleo network
     *
     * @param {Transaction | string} transaction  - The transaction to submit to the network
     * @returns {string | Error} - The transaction id of the submitted transaction or the resulting error
     */
    async submitTransaction(transaction) {
        const transaction_string = transaction instanceof Transaction ? transaction.toString() : transaction;
        try {
            const response = await post(this.host + "/transaction/broadcast", {
                body: transaction_string,
                headers: {
                    "Content-Type": "application/json",
                },
            });
            try {
                return await response.json();
            }
            catch (error) {
                throw new Error(`Error posting transaction. Aleo network response: ${error.message}`);
            }
        }
        catch (error) {
            throw new Error(`Error posting transaction: No response received: ${error.message}`);
        }
    }
}

/**
 * AleoKeyProviderParams search parameter for the AleoKeyProvider. It allows for the specification of a proverUri and
 * verifierUri to fetch keys via HTTP from a remote resource as well as a unique cacheKey to store the keys in memory.
 */
class AleoKeyProviderParams {
    proverUri;
    verifierUri;
    cacheKey;
    /**
     * Create a new AleoKeyProviderParams object which implements the KeySearchParams interface. Users can optionally
     * specify a url for the proverUri & verifierUri to fetch keys via HTTP from a remote resource as well as a unique
     * cacheKey to store the keys in memory for future use. If no proverUri or verifierUri is specified, a cachekey must
     * be provided.
     *
     * @param { AleoKeyProviderInitParams } params - Optional search parameters
     */
    constructor(params) {
        this.proverUri = params.proverUri;
        this.verifierUri = params.verifierUri;
        this.cacheKey = params.cacheKey;
    }
}
/**
 * AleoKeyProvider class. Implements the KeyProvider interface. Enables the retrieval of Aleo program proving and
 * verifying keys for the credits.aleo program over http from official Aleo sources and storing and retrieving function
 * keys from a local memory cache.
 */
class AleoKeyProvider {
    cache;
    cacheOption;
    keyUris;
    async fetchBytes(url = "/") {
        try {
            const response = await get(url);
            const data = await response.arrayBuffer();
            return new Uint8Array(data);
        }
        catch (error) {
            throw new Error("Error fetching data." + error);
        }
    }
    constructor() {
        this.keyUris = KEY_STORE;
        this.cache = new Map();
        this.cacheOption = false;
    }
    /**
     * Use local memory to store keys
     *
     * @param {boolean} useCache whether to store keys in local memory
     */
    useCache(useCache) {
        this.cacheOption = useCache;
    }
    /**
     * Clear the key cache
     */
    clearCache() {
        this.cache.clear();
    }
    /**
     * Cache a set of keys. This will overwrite any existing keys with the same keyId. The user can check if a keyId
     * exists in the cache using the containsKeys method prior to calling this method if overwriting is not desired.
     *
     * @param {string} keyId access key for the cache
     * @param {FunctionKeyPair} keys keys to cache
     */
    cacheKeys(keyId, keys) {
        const [provingKey, verifyingKey] = keys;
        this.cache.set(keyId, [provingKey.toBytes(), verifyingKey.toBytes()]);
    }
    /**
     * Determine if a keyId exists in the cache
     *
     * @param {string} keyId keyId of a proving and verifying key pair
     * @returns {boolean} true if the keyId exists in the cache, false otherwise
     */
    containsKeys(keyId) {
        return this.cache.has(keyId);
    }
    /**
     * Delete a set of keys from the cache
     *
     * @param {string} keyId keyId of a proving and verifying key pair to delete from memory
     * @returns {boolean} true if the keyId exists in the cache and was deleted, false if the key did not exist
     */
    deleteKeys(keyId) {
        return this.cache.delete(keyId);
    }
    /**
     * Get a set of keys from the cache
     * @param keyId keyId of a proving and verifying key pair
     *
     * @returns {FunctionKeyPair | Error} Proving and verifying keys for the specified program
     */
    getKeys(keyId) {
        console.debug(`Checking if key exists in cache. KeyId: ${keyId}`);
        if (this.cache.has(keyId)) {
            const [provingKeyBytes, verifyingKeyBytes] = this.cache.get(keyId);
            return [ProvingKey.fromBytes(provingKeyBytes), VerifyingKey.fromBytes(verifyingKeyBytes)];
        }
        else {
            return new Error("Key not found in cache.");
        }
    }
    /**
     * Get arbitrary function keys from a provider
     *
     * @param {KeySearchParams} params parameters for the key search in form of: {proverUri: string, verifierUri: string, cacheKey: string}
     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the specified program
     *
     * @example
     * // Create a new object which implements the KeyProvider interface
     * const networkClient = new AleoNetworkClient("https://api.explorer.aleo.org/v1");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * const AleoProviderParams = new AleoProviderParams("https://testnet3.parameters.aleo.org/transfer_private.");
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers
     * const programManager = new ProgramManager("https://api.explorer.aleo.org/v1", keyProvider, recordProvider);
     * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
     *
     * // Keys can also be fetched manually using the key provider
     * const keySearchParams = { "cacheKey": "myProgram:myFunction" };
     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.functionKeys(keySearchParams);
     */
    async functionKeys(params) {
        if (params) {
            let proverUrl;
            let verifierUrl;
            let cacheKey;
            if ("proverUri" in params && typeof params["proverUri"] == "string") {
                proverUrl = params["proverUri"];
            }
            if ("verifierUri" in params && typeof params["verifierUri"] == "string") {
                verifierUrl = params["verifierUri"];
            }
            if ("cacheKey" in params && typeof params["cacheKey"] == "string") {
                cacheKey = params["cacheKey"];
            }
            if (proverUrl && verifierUrl) {
                return await this.fetchKeys(proverUrl, verifierUrl, cacheKey);
            }
            if (cacheKey) {
                return this.getKeys(cacheKey);
            }
        }
        throw Error("Invalid parameters provided, must provide either a cacheKey and/or a proverUrl and a verifierUrl");
    }
    /**
     * Returns the proving and verifying keys for a specified program from a specified url.
     *
     * @param {string} verifierUrl Url of the proving key
     * @param {string} proverUrl Url the verifying key
     * @param {string} cacheKey Key to store the keys in the cache
     *
     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the specified program
     *
     * @example
     * // Create a new AleoKeyProvider object
     * const networkClient = new AleoNetworkClient("https://api.explorer.aleo.org/v1");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers
     * const programManager = new ProgramManager("https://vm.aleo.org/api", keyProvider, recordProvider);
     * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
     *
     * // Keys can also be fetched manually
     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.fetchKeys("https://testnet3.parameters.aleo.org/transfer_private.prover.2a9a6f2", "https://testnet3.parameters.aleo.org/transfer_private.verifier.3a59762");
     */
    async fetchKeys(proverUrl, verifierUrl, cacheKey) {
        try {
            // If cache is enabled, check if the keys have already been fetched and return them if they have
            if (this.cacheOption) {
                if (!cacheKey) {
                    cacheKey = proverUrl;
                }
                const value = this.cache.get(cacheKey);
                if (typeof value !== "undefined") {
                    return [ProvingKey.fromBytes(value[0]), VerifyingKey.fromBytes(value[1])];
                }
                else {
                    console.debug("Fetching proving keys from url " + proverUrl);
                    const provingKey = ProvingKey.fromBytes(await this.fetchBytes(proverUrl));
                    console.debug("Fetching verifying keys " + verifierUrl);
                    const verifyingKey = (await this.getVerifyingKey(verifierUrl));
                    this.cache.set(cacheKey, [provingKey.toBytes(), verifyingKey.toBytes()]);
                    return [provingKey, verifyingKey];
                }
            }
            else {
                // If cache is disabled, fetch the keys and return them
                const provingKey = ProvingKey.fromBytes(await this.fetchBytes(proverUrl));
                const verifyingKey = (await this.getVerifyingKey(verifierUrl));
                return [provingKey, verifyingKey];
            }
        }
        catch (error) {
            throw new Error(`Error: ${error} fetching fee proving and verifying keys from ${proverUrl} and ${verifierUrl}.`);
        }
    }
    /**
     * Returns the proving and verifying keys for the transfer functions in the credits.aleo program
     * @param {string} visibility Visibility of the transfer function
     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the transfer functions
     *
     * @example
     * // Create a new AleoKeyProvider
     * const networkClient = new AleoNetworkClient("https://vm.aleo.org/api");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers
     * const programManager = new ProgramManager("https://vm.aleo.org/api", keyProvider, recordProvider);
     * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
     *
     * // Keys can also be fetched manually
     * const [transferPublicProvingKey, transferPublicVerifyingKey] = await keyProvider.transferKeys("public");
     */
    async transferKeys(visibility) {
        if (PRIVATE_TRANSFER.has(visibility)) {
            return await this.fetchKeys(CREDITS_PROGRAM_KEYS.transfer_private.prover, CREDITS_PROGRAM_KEYS.transfer_private.verifier);
        }
        else if (PRIVATE_TO_PUBLIC_TRANSFER.has(visibility)) {
            return await this.fetchKeys(CREDITS_PROGRAM_KEYS.transfer_private_to_public.prover, CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifier);
        }
        else if (PUBLIC_TRANSFER.has(visibility)) {
            return await this.fetchKeys(CREDITS_PROGRAM_KEYS.transfer_public.prover, CREDITS_PROGRAM_KEYS.transfer_public.verifier);
        }
        else if (PUBLIC_TO_PRIVATE_TRANSFER.has(visibility)) {
            return await this.fetchKeys(CREDITS_PROGRAM_KEYS.transfer_public_to_private.prover, CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifier);
        }
        else {
            throw new Error("Invalid visibility type");
        }
    }
    /**
     * Returns the proving and verifying keys for the join function in the credits.aleo program
     *
     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the join function
     */
    async joinKeys() {
        return await this.fetchKeys(CREDITS_PROGRAM_KEYS.join.prover, CREDITS_PROGRAM_KEYS.join.verifier);
    }
    /**
     * Returns the proving and verifying keys for the split function in the credits.aleo program
     *
     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the split function
     * */
    async splitKeys() {
        return await this.fetchKeys(CREDITS_PROGRAM_KEYS.split.prover, CREDITS_PROGRAM_KEYS.split.verifier);
    }
    /**
     * Returns the proving and verifying keys for the fee_private function in the credits.aleo program
     *
     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the fee function
     */
    async feePrivateKeys() {
        return await this.fetchKeys(CREDITS_PROGRAM_KEYS.fee_private.prover, CREDITS_PROGRAM_KEYS.fee_private.verifier);
    }
    /**
     * Returns the proving and verifying keys for the fee_public function in the credits.aleo program
     *
     * @returns {Promise<FunctionKeyPair | Error>} Proving and verifying keys for the fee function
     */
    async feePublicKeys() {
        return await this.fetchKeys(CREDITS_PROGRAM_KEYS.fee_public.prover, CREDITS_PROGRAM_KEYS.fee_public.verifier);
    }
    /**
     * Gets a verifying key. If the verifying key is for a credits.aleo function, get it from the wasm cache otherwise
     *
     * @returns {Promise<VerifyingKey | Error>} Verifying key for the function
     */
    // attempt to fetch it from the network
    async getVerifyingKey(verifierUrl) {
        switch (verifierUrl) {
            case CREDITS_PROGRAM_KEYS.bond_public.verifier:
                return VerifyingKey.fromString(CREDITS_PROGRAM_KEYS.bond_public.verifyingKey);
            case CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier:
                return VerifyingKey.fromString(CREDITS_PROGRAM_KEYS.claim_unbond_public.verifyingKey);
            case CREDITS_PROGRAM_KEYS.fee_private.verifier:
                return VerifyingKey.fromString(CREDITS_PROGRAM_KEYS.fee_private.verifyingKey);
            case CREDITS_PROGRAM_KEYS.fee_public.verifier:
                return VerifyingKey.fromString(CREDITS_PROGRAM_KEYS.fee_public.verifyingKey);
            case CREDITS_PROGRAM_KEYS.inclusion.verifier:
                return VerifyingKey.fromString(CREDITS_PROGRAM_KEYS.inclusion.verifyingKey);
            case CREDITS_PROGRAM_KEYS.join.verifier:
                return VerifyingKey.fromString(CREDITS_PROGRAM_KEYS.join.verifyingKey);
            case CREDITS_PROGRAM_KEYS.split.verifier:
                return VerifyingKey.fromString(CREDITS_PROGRAM_KEYS.split.verifyingKey);
            case CREDITS_PROGRAM_KEYS.transfer_private.verifier:
                return VerifyingKey.fromString(CREDITS_PROGRAM_KEYS.transfer_private.verifyingKey);
            case CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifier:
                return VerifyingKey.fromString(CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifyingKey);
            case CREDITS_PROGRAM_KEYS.transfer_public.verifier:
                return VerifyingKey.fromString(CREDITS_PROGRAM_KEYS.transfer_public.verifyingKey);
            case CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifier:
                return VerifyingKey.fromString(CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifyingKey);
            case CREDITS_PROGRAM_KEYS.unbond_public.verifier:
                return VerifyingKey.fromString(CREDITS_PROGRAM_KEYS.unbond_public.verifyingKey);
            default:
                return VerifyingKey.fromBytes(await this.fetchBytes(verifierUrl));
        }
    }
}

/**
 * A record provider implementation that uses the official Aleo API to find records for usage in program execution and
 * deployment, wallet functionality, and other use cases.
 */
class NetworkRecordProvider {
    account;
    networkClient;
    constructor(account, networkClient) {
        this.account = account;
        this.networkClient = networkClient;
    }
    /**
     * Set the account used to search for records
     *
     * @param {Account} account The account to use for searching for records
     */
    setAccount(account) {
        this.account = account;
    }
    /**
     * Find a list of credit records with a given number of microcredits by via the official Aleo API
     *
     * @param {number[]} microcredits The number of microcredits to search for
     * @param {boolean} unspent Whether or not the record is unspent
     * @param {string[]} nonces Nonces of records already found so that they are not found again
     * @param {RecordSearchParams} searchParameters Additional parameters to search for
     * @returns {Promise<RecordPlaintext | Error>} The record if found, otherwise an error
     *
     * @example
     * // Create a new NetworkRecordProvider
     * const networkClient = new AleoNetworkClient("https://api.explorer.aleo.org/v1");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // The record provider can be used to find records with a given number of microcredits
     * const record = await recordProvider.findCreditsRecord(5000, true, []);
     *
     * // When a record is found but not yet used, it's nonce should be added to the nonces parameter so that it is not
     * // found again if a subsequent search is performed
     * const records = await recordProvider.findCreditsRecords(5000, true, [record.nonce()]);
     *
     * // When the program manager is initialized with the record provider it will be used to find automatically find
     * // fee records and amount records for value transfers so that they do not need to be specified manually
     * const programManager = new ProgramManager("https://api.explorer.aleo.org/v1", keyProvider, recordProvider);
     * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
     *
     * */
    async findCreditsRecords(microcredits, unspent, nonces, searchParameters) {
        let startHeight = 0;
        let endHeight = 0;
        if (searchParameters) {
            if ("startHeight" in searchParameters && typeof searchParameters["endHeight"] == "number") {
                startHeight = searchParameters["startHeight"];
            }
            if ("endHeight" in searchParameters && typeof searchParameters["endHeight"] == "number") {
                endHeight = searchParameters["endHeight"];
            }
        }
        // If the end height is not specified, use the current block height
        if (endHeight == 0) {
            const end = await this.networkClient.getLatestHeight();
            if (end instanceof Error) {
                throw logAndThrow("Unable to get current block height from the network");
            }
            endHeight = end;
        }
        // If the start height is greater than the end height, throw an error
        if (startHeight >= endHeight) {
            throw logAndThrow("Start height must be less than end height");
        }
        return await this.networkClient.findUnspentRecords(startHeight, endHeight, this.account.privateKey(), microcredits, undefined, nonces);
    }
    /**
     * Find a credit record with a given number of microcredits by via the official Aleo API
     *
     * @param {number} microcredits The number of microcredits to search for
     * @param {boolean} unspent Whether or not the record is unspent
     * @param {string[]} nonces Nonces of records already found so that they are not found again
     * @param {RecordSearchParams} searchParameters Additional parameters to search for
     * @returns {Promise<RecordPlaintext | Error>} The record if found, otherwise an error
     *
     * @example
     * // Create a new NetworkRecordProvider
     * const networkClient = new AleoNetworkClient("https://api.explorer.aleo.org/v1");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // The record provider can be used to find records with a given number of microcredits
     * const record = await recordProvider.findCreditsRecord(5000, true, []);
     *
     * // When a record is found but not yet used, it's nonce should be added to the nonces parameter so that it is not
     * // found again if a subsequent search is performed
     * const records = await recordProvider.findCreditsRecords(5000, true, [record.nonce()]);
     *
     * // When the program manager is initialized with the record provider it will be used to find automatically find
     * // fee records and amount records for value transfers so that they do not need to be specified manually
     * const programManager = new ProgramManager("https://api.explorer.aleo.org/v1", keyProvider, recordProvider);
     * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
     */
    async findCreditsRecord(microcredits, unspent, nonces, searchParameters) {
        const records = await this.findCreditsRecords([microcredits], unspent, nonces, searchParameters);
        if (!(records instanceof Error) && records.length > 0) {
            return records[0];
        }
        console.error("Record not found with error:", records);
        return new Error("Record not found");
    }
    /**
     * Find an arbitrary record. WARNING: This function is not implemented yet and will throw an error.
     */
    async findRecord(unspent, nonces, searchParameters) {
        throw new Error("Method not implemented.");
    }
    /**
     * Find multiple arbitrary records. WARNING: This function is not implemented yet and will throw an error.
     */
    async findRecords(unspent, nonces, searchParameters) {
        throw new Error("Method not implemented.");
    }
}
/**
 * BlockHeightSearch is a RecordSearchParams implementation that allows for searching for records within a given
 * block height range.
 *
 * @example
 * // Create a new BlockHeightSearch
 * const params = new BlockHeightSearch(89995, 99995);
 *
 * // Create a new NetworkRecordProvider
 * const networkClient = new AleoNetworkClient("https://api.explorer.aleo.org/v1");
 * const keyProvider = new AleoKeyProvider();
 * const recordProvider = new NetworkRecordProvider(account, networkClient);
 *
 * // The record provider can be used to find records with a given number of microcredits and the block height search
 * // can be used to find records within a given block height range
 * const record = await recordProvider.findCreditsRecord(5000, true, [], params);
 *
 */
class BlockHeightSearch {
    startHeight;
    endHeight;
    constructor(startHeight, endHeight) {
        this.startHeight = startHeight;
        this.endHeight = endHeight;
    }
}

// Experimental example where SDK manages worker
let singletonWorker = null;
const createAleoWorker = () => {
    if (!singletonWorker) {
        const worker = new Worker(new URL("worker.js", import.meta.url), {
            type: "module",
        });
        singletonWorker = wrap(worker);
    }
    return singletonWorker;
};

/**
 * The ProgramManager class is used to execute and deploy programs on the Aleo network and create value transfers.
 */
class ProgramManager {
    account;
    keyProvider;
    host;
    networkClient;
    recordProvider;
    /** Create a new instance of the ProgramManager
     *
     * @param { string | undefined } host A host uri running the official Aleo API
     * @param { FunctionKeyProvider | undefined } keyProvider A key provider that implements {@link FunctionKeyProvider} interface
     * @param { RecordProvider | undefined } recordProvider A record provider that implements {@link RecordProvider} interface
     */
    constructor(host, keyProvider, recordProvider) {
        if (!host) {
            this.host = "https://api.explorer.aleo.org/v1";
            this.networkClient = new AleoNetworkClient(this.host);
        }
        else {
            this.host = host;
            this.networkClient = new AleoNetworkClient(host);
        }
        if (!keyProvider) {
            this.keyProvider = new AleoKeyProvider();
        }
        else {
            this.keyProvider = keyProvider;
        }
        this.recordProvider = recordProvider;
    }
    /**
     * Set the account to use for transaction submission to the Aleo network
     *
     * @param {Account} account Account to use for transaction submission
     */
    setAccount(account) {
        this.account = account;
    }
    /**
     * Set the key provider that provides the proving and verifying keys for programs
     *
     * @param {FunctionKeyProvider} keyProvider
     */
    setKeyProvider(keyProvider) {
        this.keyProvider = keyProvider;
    }
    /**
     * Set the host peer to use for transaction submission to the Aleo network
     *
     * @param host {string} Peer url to use for transaction submission
     */
    setHost(host) {
        this.host = host;
        this.networkClient.setHost(host);
    }
    /**
     * Set the record provider that provides records for transactions
     *
     * @param {RecordProvider} recordProvider
     */
    setRecordProvider(recordProvider) {
        this.recordProvider = recordProvider;
    }
    /**
     * Deploy an Aleo program to the Aleo network
     *
     * @param {string} program Program source code
     * @param {number} fee Fee to pay for the transaction
     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for searching for a record to use
     * pay the deployment fee
     * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction
     * @returns {string | Error} The transaction id of the deployed program or a failure message from the network
     *
     * @example
     * // Create a new NetworkClient, KeyProvider, and RecordProvider
     * const networkClient = new AleoNetworkClient("https://api.explorer.aleo.org/v1");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for deployments
     * const program = "program hello_hello.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n";
     * const programManager = new ProgramManager("https://api.explorer.aleo.org/v1", keyProvider, recordProvider);
     *
     * // Define a fee in credits
     * const fee = 1.2;
     *
     * // Deploy the program
     * const tx_id = await programManager.deploy(program, fee);
     *
     * // Verify the transaction was successful
     * const transaction = await programManager.networkClient.getTransaction(tx_id);
     */
    async deploy(program, fee, privateFee, recordSearchParams, feeRecord, privateKey) {
        // Ensure the program is valid and does not exist on the network
        try {
            const programObject = Program.fromString(program);
            let programSource;
            try {
                programSource = await this.networkClient.getProgram(programObject.id());
            }
            catch (e) {
                // Program does not exist on the network, deployment can proceed
                console.log(`Program ${programObject.id()} does not exist on the network, deploying...`);
            }
            if (typeof programSource == "string") {
                throw (`Program ${programObject.id()} already exists on the network, please rename your program`);
            }
        }
        catch (e) {
            throw logAndThrow(`Error validating program: ${e}`);
        }
        // Get the private key from the account if it is not provided in the parameters
        let deploymentPrivateKey = privateKey;
        if (typeof privateKey === "undefined" && typeof this.account !== "undefined") {
            deploymentPrivateKey = this.account.privateKey();
        }
        if (typeof deploymentPrivateKey === "undefined") {
            throw ("No private key provided and no private key set in the ProgramManager");
        }
        // Get the fee record from the account if it is not provided in the parameters
        try {
            feeRecord = privateFee ? await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams) : undefined;
        }
        catch (e) {
            throw logAndThrow(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
        }
        // Get the proving and verifying keys from the key provider
        let feeKeys;
        try {
            feeKeys = privateFee ? await this.keyProvider.feePrivateKeys() : await this.keyProvider.feePublicKeys();
        }
        catch (e) {
            throw logAndThrow(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`);
        }
        const [feeProvingKey, feeVerifyingKey] = feeKeys;
        // Resolve the program imports if they exist
        let imports;
        try {
            imports = await this.networkClient.getProgramImports(program);
        }
        catch (e) {
            throw logAndThrow(`Error finding program imports. Network response: '${e}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);
        }
        // Build a deployment transaction and submit it to the network
        const tx = await ProgramManager$1.buildDeploymentTransaction(deploymentPrivateKey, program, fee, feeRecord, this.host, imports, feeProvingKey, feeVerifyingKey);
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Build an execution transaction for later submission to the Aleo network.
     *
     * @param {string} programName Program name containing the function to be executed
     * @param {string} functionName Function name to execute
     * @param {number} fee Fee to pay for the transaction
     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
     * @param {string[]} inputs Inputs to the function
     * @param {RecordSearchParams} recordSearchParams Optional parameters for searching for a record to pay the fee for
     * the execution transaction
     * @param {KeySearchParams} keySearchParams Optional parameters for finding the matching proving & verifying keys
     * for the function
     * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction
     * @param {ProvingKey | undefined} provingKey Optional proving key to use for the transaction
     * @param {VerifyingKey | undefined} verifyingKey Optional verifying key to use for the transaction
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<string | Error>}
     *
     * @example
     * // Create a new NetworkClient, KeyProvider, and RecordProvider using official Aleo record, key, and network providers
     * const networkClient = new AleoNetworkClient("https://vm.aleo.org/api");
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache = true;
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions
     * const programName = "hello_hello.aleo";
     * const programManager = new ProgramManager("https://vm.aleo.org/api", keyProvider, recordProvider);
     * const keySearchParams = { "cacheKey": "hello_hello:hello" };
     * const transaction = await programManager.execute(programName, "hello_hello", 0.020, ["5u32", "5u32"], undefined, undefined, undefined, keySearchParams);
     * const result = await programManager.networkClient.submitTransaction(transaction);
     */
    async buildExecutionTransaction(programName, functionName, fee, privateFee, inputs, recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey, offlineQuery) {
        // Ensure the function exists on the network
        let program;
        try {
            program = (await this.networkClient.getProgram(programName));
        }
        catch (e) {
            throw logAndThrow(`Error finding ${programName}. Network response: '${e}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`);
        }
        // Get the private key from the account if it is not provided in the parameters
        let executionPrivateKey = privateKey;
        if (typeof privateKey === "undefined" && typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
        }
        if (typeof executionPrivateKey === "undefined") {
            throw ("No private key provided and no private key set in the ProgramManager");
        }
        // Get the fee record from the account if it is not provided in the parameters
        try {
            feeRecord = privateFee ? await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams) : undefined;
        }
        catch (e) {
            throw logAndThrow(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
        }
        // Get the fee proving and verifying keys from the key provider
        let feeKeys;
        try {
            feeKeys = privateFee ? await this.keyProvider.feePrivateKeys() : await this.keyProvider.feePublicKeys();
        }
        catch (e) {
            throw logAndThrow(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`);
        }
        const [feeProvingKey, feeVerifyingKey] = feeKeys;
        // If the function proving and verifying keys are not provided, attempt to find them using the key provider
        if (!provingKey || !verifyingKey) {
            try {
                [provingKey, verifyingKey] = await this.keyProvider.functionKeys(keySearchParams);
            }
            catch (e) {
                console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`);
            }
        }
        // Resolve the program imports if they exist
        let imports;
        try {
            imports = await this.networkClient.getProgramImports(programName);
        }
        catch (e) {
            throw logAndThrow(`Error finding program imports. Network response: '${e}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);
        }
        // Build an execution transaction and submit it to the network
        return await ProgramManager$1.buildExecutionTransaction(executionPrivateKey, program, functionName, inputs, fee, feeRecord, this.host, imports, provingKey, verifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery);
    }
    /**
     * Execute an Aleo program on the Aleo network
     *
     * @param {string} programName Program name containing the function to be executed
     * @param {string} functionName Function name to execute
     * @param {number} fee Fee to pay for the transaction
     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
     * @param {string[]} inputs Inputs to the function
     * @param {RecordSearchParams} recordSearchParams Optional parameters for searching for a record to pay the fee for
     * the execution transaction
     * @param {KeySearchParams} keySearchParams Optional parameters for finding the matching proving & verifying keys
     * for the function
     * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction
     * @param {ProvingKey | undefined} provingKey Optional proving key to use for the transaction
     * @param {VerifyingKey | undefined} verifyingKey Optional verifying key to use for the transaction
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<string | Error>}
     *
     * @example
     * // Create a new NetworkClient, KeyProvider, and RecordProvider using official Aleo record, key, and network providers
     * const networkClient = new AleoNetworkClient("https://vm.aleo.org/api");
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache = true;
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions
     * const programName = "hello_hello.aleo";
     * const programManager = new ProgramManager("https://vm.aleo.org/api", keyProvider, recordProvider);
     * const keySearchParams = { "cacheKey": "hello_hello:hello" };
     * const tx_id = await programManager.execute(programName, "hello_hello", 0.020, ["5u32", "5u32"], undefined, undefined, undefined, keySearchParams);
     * const transaction = await programManager.networkClient.getTransaction(tx_id);
     */
    async execute(programName, functionName, fee, privateFee, inputs, recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey, offlineQuery) {
        const tx = await this.buildExecutionTransaction(programName, functionName, fee, privateFee, inputs, recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey, offlineQuery);
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Run an Aleo program in offline mode
     *
     * @param {string} program Program source code containing the function to be executed
     * @param {string} function_name Function name to execute
     * @param {string[]} inputs Inputs to the function
     * @param {number} proveExecution Whether to prove the execution of the function and return an execution transcript
     * that contains the proof.
     * @param {string[] | undefined} imports Optional imports to the program
     * @param {KeySearchParams | undefined} keySearchParams Optional parameters for finding the matching proving &
     * verifying keys for the function
     * @param {ProvingKey | undefined} provingKey Optional proving key to use for the transaction
     * @param {VerifyingKey | undefined} verifyingKey Optional verifying key to use for the transaction
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<string | Error>}
     *
     * @example
     * import { Account, Program } from '@aleohq/sdk';
     *
     * /// Create the source for the "helloworld" program
     * const program = "program helloworld.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n";
     * const programManager = new ProgramManager();
     *
     * /// Create a temporary account for the execution of the program
     * const account = new Account();
     * programManager.setAccount(account);
     *
     * /// Get the response and ensure that the program executed correctly
     * const executionResponse = await programManager.executeOffline(program, "hello", ["5u32", "5u32"]);
     * const result = executionResponse.getOutputs();
     * assert(result === ["10u32"]);
     */
    async run(program, function_name, inputs, proveExecution, imports, keySearchParams, provingKey, verifyingKey, privateKey, offlineQuery) {
        // Get the private key from the account if it is not provided in the parameters
        let executionPrivateKey = privateKey;
        if (typeof privateKey === "undefined" && typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
        }
        if (typeof executionPrivateKey === "undefined") {
            throw ("No private key provided and no private key set in the ProgramManager");
        }
        // If the function proving and verifying keys are not provided, attempt to find them using the key provider
        if (!provingKey || !verifyingKey) {
            try {
                [provingKey, verifyingKey] = await this.keyProvider.functionKeys(keySearchParams);
            }
            catch (e) {
                console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`);
            }
        }
        // Run the program offline and return the result
        console.log("Running program offline");
        console.log("Proving key: ", provingKey);
        console.log("Verifying key: ", verifyingKey);
        return ProgramManager$1.executeFunctionOffline(executionPrivateKey, program, function_name, inputs, proveExecution, false, imports, provingKey, verifyingKey, this.host, offlineQuery);
    }
    /**
     * Join two credits records into a single credits record
     *
     * @param {RecordPlaintext | string} recordOne First credits record to join
     * @param {RecordPlaintext | string} recordTwo Second credits record to join
     * @param {number} fee Fee in credits pay for the join transaction
     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the fee record to use
     * to pay the fee for the join transaction
     * @param {RecordPlaintext | string | undefined} feeRecord Fee record to use for the join transaction
     * @param {PrivateKey | undefined} privateKey Private key to use for the join transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<string | Error>}
     */
    async join(recordOne, recordTwo, fee, privateFee, recordSearchParams, feeRecord, privateKey, offlineQuery) {
        // Get the private key from the account if it is not provided in the parameters
        let executionPrivateKey = privateKey;
        if (typeof privateKey === "undefined" && typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
        }
        if (typeof executionPrivateKey === "undefined") {
            throw ("No private key provided and no private key set in the ProgramManager");
        }
        // Get the proving and verifying keys from the key provider
        let feeKeys;
        let joinKeys;
        try {
            feeKeys = privateFee ? await this.keyProvider.feePrivateKeys() : await this.keyProvider.feePublicKeys();
            joinKeys = await this.keyProvider.joinKeys();
        }
        catch (e) {
            throw logAndThrow(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`);
        }
        const [feeProvingKey, feeVerifyingKey] = feeKeys;
        const [joinProvingKey, joinVerifyingKey] = joinKeys;
        // Get the fee record from the account if it is not provided in the parameters
        try {
            feeRecord = privateFee ? await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams) : undefined;
        }
        catch (e) {
            throw logAndThrow(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
        }
        // Validate the records provided are valid plaintext records
        try {
            recordOne = recordOne instanceof RecordPlaintext ? recordOne : RecordPlaintext.fromString(recordOne);
            recordTwo = recordTwo instanceof RecordPlaintext ? recordTwo : RecordPlaintext.fromString(recordTwo);
        }
        catch (e) {
            throw logAndThrow('Records provided are not valid. Please ensure they are valid plaintext records.');
        }
        // Build an execution transaction and submit it to the network
        const tx = await ProgramManager$1.buildJoinTransaction(executionPrivateKey, recordOne, recordTwo, fee, feeRecord, this.host, joinProvingKey, joinVerifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery);
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Split credits into two new credits records
     *
     * @param {number} splitAmount Amount in microcredits to split from the original credits record
     * @param {RecordPlaintext | string} amountRecord Amount record to use for the split transaction
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the split transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<string | Error>}
     *
     * @example
     * // Create a new NetworkClient, KeyProvider, and RecordProvider
     * const networkClient = new AleoNetworkClient("https://vm.aleo.org/api");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions
     * const programName = "hello_hello.aleo";
     * const programManager = new ProgramManager("https://vm.aleo.org/api", keyProvider, recordProvider);
     * const record = "{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 4106205762862305308495708971985748592380064201230396559307556388725936304984group.public}"
     * const tx_id = await programManager.split(25000000, record);
     * const transaction = await programManager.networkClient.getTransaction(tx_id);
     */
    async split(splitAmount, amountRecord, privateKey, offlineQuery) {
        // Get the private key from the account if it is not provided in the parameters
        let executionPrivateKey = privateKey;
        if (typeof executionPrivateKey === "undefined" && typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
        }
        if (typeof executionPrivateKey === "undefined") {
            throw ("No private key provided and no private key set in the ProgramManager");
        }
        // Get the split keys from the key provider
        let splitKeys;
        try {
            splitKeys = await this.keyProvider.splitKeys();
        }
        catch (e) {
            throw logAndThrow(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`);
        }
        const [splitProvingKey, splitVerifyingKey] = splitKeys;
        // Validate the record to be split
        try {
            amountRecord = amountRecord instanceof RecordPlaintext ? amountRecord : RecordPlaintext.fromString(amountRecord);
        }
        catch (e) {
            throw logAndThrow("Record provided is not valid. Please ensure it is a valid plaintext record.");
        }
        // Build an execution transaction and submit it to the network
        const tx = await ProgramManager$1.buildSplitTransaction(executionPrivateKey, splitAmount, amountRecord, this.host, splitProvingKey, splitVerifyingKey, offlineQuery);
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Pre-synthesize proving and verifying keys for a program
     *
     * @param program {string} The program source code to synthesize keys for
     * @param function_id {string} The function id to synthesize keys for
     * @param inputs {Array<string>}  Sample inputs to the function
     * @param privateKey {PrivateKey | undefined} Optional private key to use for the key synthesis
     *
     * @returns {Promise<FunctionKeyPair | Error>}
     */
    async synthesizeKeys(program, function_id, inputs, privateKey) {
        // Resolve the program imports if they exist
        let imports;
        let executionPrivateKey = privateKey;
        if (typeof executionPrivateKey === "undefined") {
            if (typeof this.account !== "undefined") {
                executionPrivateKey = this.account.privateKey();
            }
            else {
                executionPrivateKey = new PrivateKey();
            }
        }
        // Attempt to run an offline execution of the program and extract the proving and verifying keys
        try {
            imports = await this.networkClient.getProgramImports(program);
            const keyPair = await ProgramManager$1.synthesizeKeyPair(executionPrivateKey, program, function_id, inputs, imports);
            return [keyPair.provingKey(), keyPair.verifyingKey()];
        }
        catch (e) {
            throw logAndThrow(`Could not synthesize keys - error ${e}. Please ensure the program is valid and the inputs are correct.`);
        }
    }
    /**
     * Build a transaction to transfer credits to another account for later submission to the Aleo network
     *
     * @param {number} amount The amount of credits to transfer
     * @param {string} recipient The recipient of the transfer
     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'
     * @param {number} fee The fee to pay for the transfer
     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee
     * records for the transfer transaction
     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer
     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<string | Error>} The transaction id of the transfer transaction
     *
     * @example
     * // Create a new NetworkClient, KeyProvider, and RecordProvider
     * const networkClient = new AleoNetworkClient("https://vm.aleo.org/api");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions
     * const programName = "hello_hello.aleo";
     * const programManager = new ProgramManager("https://vm.aleo.org/api", keyProvider, recordProvider);
     * await programManager.initialize();
     * const tx_id = await programManager.transfer(1, "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "private", 0.2)
     * const transaction = await programManager.networkClient.getTransaction(tx_id);
     */
    async buildTransferTransaction(amount, recipient, transferType, fee, privateFee, recordSearchParams, amountRecord, feeRecord, privateKey, offlineQuery) {
        // Validate the transfer type
        transferType = validateTransferType(transferType);
        // Get the private key from the account if it is not provided in the parameters
        let executionPrivateKey = privateKey;
        if (typeof executionPrivateKey === "undefined" && typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
        }
        if (typeof executionPrivateKey === "undefined") {
            throw ("No private key provided and no private key set in the ProgramManager");
        }
        // Get the proving and verifying keys from the key provider
        let feeKeys;
        let transferKeys;
        try {
            feeKeys = privateFee ? await this.keyProvider.feePrivateKeys() : await this.keyProvider.feePublicKeys();
            transferKeys = await this.keyProvider.transferKeys(transferType);
        }
        catch (e) {
            throw logAndThrow(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`);
        }
        const [feeProvingKey, feeVerifyingKey] = feeKeys;
        const [transferProvingKey, transferVerifyingKey] = transferKeys;
        // Get the amount and fee record from the account if it is not provided in the parameters
        try {
            // Track the nonces of the records found so no duplicate records are used
            const nonces = [];
            if (requiresAmountRecord(transferType)) {
                // If the transfer type is private and requires an amount record, get it from the record provider
                amountRecord = await this.getCreditsRecord(fee, [], amountRecord, recordSearchParams);
                nonces.push(amountRecord.nonce());
            }
            else {
                amountRecord = undefined;
            }
            feeRecord = privateFee ? await this.getCreditsRecord(fee, nonces, feeRecord, recordSearchParams) : undefined;
        }
        catch (e) {
            throw logAndThrow(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
        }
        // Build an execution transaction and submit it to the network
        return await ProgramManager$1.buildTransferTransaction(executionPrivateKey, amount, recipient, transferType, amountRecord, fee, feeRecord, this.host, transferProvingKey, transferVerifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery);
    }
    /**
     * Build a transfer_public transaction to transfer credits to another account for later submission to the Aleo network
     *
     * @param {number} amount The amount of credits to transfer
     * @param {string} recipient The recipient of the transfer
     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'
     * @param {number} fee The fee to pay for the transfer
     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee
     * records for the transfer transaction
     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer
     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<string | Error>} The transaction id of the transfer transaction
     *
     * @example
     * // Create a new NetworkClient, KeyProvider, and RecordProvider
     * const networkClient = new AleoNetworkClient("https://vm.aleo.org/api");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions
     * const programName = "hello_hello.aleo";
     * const programManager = new ProgramManager("https://vm.aleo.org/api", keyProvider, recordProvider);
     * await programManager.initialize();
     * const tx_id = await programManager.transfer(1, "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "private", 0.2)
     * const transaction = await programManager.networkClient.getTransaction(tx_id);
     */
    async buildTransferPublicTransaction(amount, recipient, fee, privateKey, offlineQuery) {
        return this.buildTransferTransaction(amount, recipient, "public", fee, false, undefined, undefined, undefined, privateKey, offlineQuery);
    }
    /**
     * Transfer credits to another account
     *
     * @param {number} amount The amount of credits to transfer
     * @param {string} recipient The recipient of the transfer
     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'
     * @param {number} fee The fee to pay for the transfer
     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee
     * records for the transfer transaction
     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer
     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<string | Error>} The transaction id of the transfer transaction
     *
     * @example
     * // Create a new NetworkClient, KeyProvider, and RecordProvider
     * const networkClient = new AleoNetworkClient("https://vm.aleo.org/api");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions
     * const programName = "hello_hello.aleo";
     * const programManager = new ProgramManager("https://vm.aleo.org/api", keyProvider, recordProvider);
     * await programManager.initialize();
     * const tx_id = await programManager.transfer(1, "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "private", 0.2)
     * const transaction = await programManager.networkClient.getTransaction(tx_id);
     */
    async transfer(amount, recipient, transferType, fee, privateFee, recordSearchParams, amountRecord, feeRecord, privateKey, offlineQuery) {
        const tx = await this.buildTransferTransaction(amount, recipient, transferType, fee, privateFee, recordSearchParams, amountRecord, feeRecord, privateKey, offlineQuery);
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Build transaction to bond credits to a staking committee for later submission to the Aleo Network
     *
     * @example
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache = true;
     *
     * // Create a new ProgramManager with the key that will be used to bond credits
     * const programManager = new ProgramManager("https://api.explorer.aleo.org/v1", keyProvider, undefined);
     * programManager.setAccount(new Account("YourPrivateKey"));
     *
     * // Create the bonding transaction
     * const tx_id = await programManager.bondPublic("aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", 2000000);
     *
     * @returns string
     * @param {string} address Address of the validator to bond to, if this address is the same as the signer (i.e. the
     * executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently
     * requires a minimum of 1,000,000 credits to bond (subject to change). If the address is specified is an existing
     * validator and is different from the address of the executor of this function, it will bond the credits to that
     * validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.
     * @param {number} amount The amount of credits to bond
     * @param {Options} options Options for the execution
     */
    async buildBondPublicTransaction(address, amount, options = {}) {
        amount = Math.trunc(amount * 1000000);
        const { offlineParams = {}, executionParams = {} } = options || {};
        let { programName = "credits.aleo", functionName = "bond_public", fee = executionParams?.fee || 0.86, privateFee = false, recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey } = executionParams;
        if (keySearchParams === undefined) {
            keySearchParams = new AleoKeyProviderParams({
                proverUri: CREDITS_PROGRAM_KEYS.bond_public.prover,
                verifierUri: CREDITS_PROGRAM_KEYS.bond_public.verifier,
                cacheKey: "credits.aleo/bond_public"
            });
        }
        const { offlineQuery, } = offlineParams;
        return await this.buildExecutionTransaction(programName, functionName, fee, privateFee, [address, `${amount.toString()}u64`], recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey, offlineQuery);
    }
    /**
     * Bond credits to a staking committee
     *
     * @example
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache = true;
     *
     * // Create a new ProgramManager with the key that will be used to bond credits
     * const programManager = new ProgramManager("https://api.explorer.aleo.org/v1", keyProvider, undefined);
     * programManager.setAccount(new Account("YourPrivateKey"));
     *
     * // Create the bonding transaction
     * const tx_id = await programManager.bondPublic("aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", 2000000);
     *
     * @returns string
     * @param {string} address Address of the validator to bond to, if this address is the same as the signer (i.e. the
     * executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently
     * requires a minimum of 1,000,000 credits to bond (subject to change). If the address is specified is an existing
     * validator and is different from the address of the executor of this function, it will bond the credits to that
     * validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.
     * @param {number} amount The amount of credits to bond
     * @param {Options} options Options for the execution
     */
    async bondPublic(address, amount, options = {}) {
        const tx = await this.buildBondPublicTransaction(address, amount, options);
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Build a transaction to unbond a specified amount of staked credits to be used later
     *
     * @example
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache = true;
     *
     * // Create a new ProgramManager with the key that will be used to bond credits
     * const programManager = new ProgramManager("https://api.explorer.aleo.org/v1", keyProvider, undefined);
     * programManager.setAccount(new Account("YourPrivateKey"));
     *
     * // Create the bonding transaction
     * const tx_id = await programManager.unbondPublic(10);
     *
     * @returns string
     * @param {number} amount Amount of credits to unbond. If the address of the executor of this function is an
     * existing validator, it will subtract this amount of credits from the validator's staked credits. If there are
     * less than 1,000,000 credits staked pool after the unbond, the validator will be removed from the validator set.
     * If the address of the executor of this function is not a validator and has credits bonded as a delegator, it will
     * subtract this amount of credits from the delegator's staked credits. If there are less than 10 credits bonded
     * after the unbond operation, the delegator will be removed from the validator's staking pool.
     * @param {Options} options Options for the execution
     */
    async buildUnbondPublicTransaction(amount, options = {}) {
        amount = Math.trunc(amount * 1000000);
        const { offlineParams = {}, executionParams = {} } = options || {};
        let { programName = "credits.aleo", functionName = "unbond_public", fee = executionParams?.fee || 1.3, privateFee = false, recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey } = executionParams;
        if (keySearchParams === undefined) {
            keySearchParams = new AleoKeyProviderParams({
                proverUri: CREDITS_PROGRAM_KEYS.unbond_public.prover,
                verifierUri: CREDITS_PROGRAM_KEYS.unbond_public.verifier,
                cacheKey: "credits.aleo/unbond_public"
            });
        }
        const { offlineQuery, } = offlineParams;
        return this.buildExecutionTransaction(programName, functionName, fee, privateFee, [`${amount.toString()}u64`], recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey, offlineQuery);
    }
    /**
     * Unbond a specified amount of staked credits to be used later
     *
     * @example
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache = true;
     *
     * // Create a new ProgramManager with the key that will be used to bond credits
     * const programManager = new ProgramManager("https://api.explorer.aleo.org/v1", keyProvider, undefined);
     * programManager.setAccount(new Account("YourPrivateKey"));
     *
     * // Create the bonding transaction
     * const tx_id = await programManager.unbondPublic(10);
     *
     * @returns string
     * @param {number} amount Amount of credits to unbond. If the address of the executor of this function is an
     * existing validator, it will subtract this amount of credits from the validator's staked credits. If there are
     * less than 1,000,000 credits staked pool after the unbond, the validator will be removed from the validator set.
     * If the address of the executor of this function is not a validator and has credits bonded as a delegator, it will
     * subtract this amount of credits from the delegator's staked credits. If there are less than 10 credits bonded
     * after the unbond operation, the delegator will be removed from the validator's staking pool.
     * @param {Options} options Options for the execution
     */
    async unbondPublic(amount, options = {}) {
        const tx = await this.buildUnbondPublicTransaction(amount, options);
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Build a transaction to Claim unbonded credits for later submission. If credits have been unbonded by the account
     * executing this function, this method will claim them and add them to the public balance of the account.
     *
     * @example
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache = true;
     *
     * // Create a new ProgramManager with the key that will be used to bond credits
     * const programManager = new ProgramManager("https://api.explorer.aleo.org/v1", keyProvider, undefined);
     * programManager.setAccount(new Account("YourPrivateKey"));
     *
     * // Create the bonding transaction
     * const tx_id = await programManager.claimUnbondPublic();
     *
     * @returns string
     * @param {Options} options
     */
    async buildClaimUnbondPublicTransaction(options = {}) {
        const { offlineParams = {}, executionParams = {} } = options || {};
        let { programName = "credits.aleo", functionName = "claim_unbond_public", fee = executionParams?.fee || 2, privateFee = false, recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey } = executionParams;
        if (keySearchParams === undefined) {
            keySearchParams = new AleoKeyProviderParams({
                proverUri: CREDITS_PROGRAM_KEYS.claim_unbond_public.prover,
                verifierUri: CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier,
                cacheKey: "credits.aleo/claim_unbond_public"
            });
        }
        const { offlineQuery, } = offlineParams;
        return await this.buildExecutionTransaction(programName, functionName, fee, privateFee, [], recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey, offlineQuery);
    }
    /**
     * Claim unbonded credits. If credits have been unbonded by the account executing this function, this method will
     * claim them and add them to the public balance of the account.
     *
     * @example
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache = true;
     *
     * // Create a new ProgramManager with the key that will be used to bond credits
     * const programManager = new ProgramManager("https://api.explorer.aleo.org/v1", keyProvider, undefined);
     * programManager.setAccount(new Account("YourPrivateKey"));
     *
     * // Create the bonding transaction
     * const tx_id = await programManager.claimUnbondPublic();
     *
     * @returns string
     * @param {Options} options
     */
    async claimUnbondPublic(options = {}) {
        const tx = await this.buildClaimUnbondPublicTransaction(options);
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Set Validator State
     * @returns string
     * @param {boolean} validator_state
     * @param options
     */
    async setValidatorState(validator_state, options = {}) {
        const { offlineParams = {}, executionParams = {} } = options || {};
        let { programName = "credits.aleo", functionName = "set_validator_state", fee = 1, privateFee = false, recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey } = executionParams;
        if (keySearchParams === undefined) {
            keySearchParams = new AleoKeyProviderParams({
                proverUri: CREDITS_PROGRAM_KEYS.set_validator_state.prover,
                verifierUri: CREDITS_PROGRAM_KEYS.set_validator_state.verifier,
                cacheKey: "credits.aleo/set_validator_state"
            });
        }
        const { offlineQuery, } = offlineParams;
        return await this.execute(programName, functionName, fee, privateFee, [validator_state.toString()], recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey, offlineQuery);
    }
    /**
     * Unbond Delegator As Validator
     * @returns string
     * @param {string} address
     * @param options
     */
    async unbondDelegatorAsValidator(address, options = {}) {
        const { offlineParams = {}, executionParams = {} } = options || {};
        let { programName = "credits.aleo", functionName = "unbond_delegator_as_validator", fee = 1, privateFee = false, recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey } = executionParams;
        if (keySearchParams === undefined) {
            keySearchParams = new AleoKeyProviderParams({
                proverUri: CREDITS_PROGRAM_KEYS.unbond_delegator_as_validator.prover,
                verifierUri: CREDITS_PROGRAM_KEYS.unbond_delegator_as_validator.verifier,
                cacheKey: "credits.aleo/unbond_delegator_as_validator"
            });
        }
        const { offlineQuery, } = offlineParams;
        return await this.execute(programName, functionName, fee, privateFee, [address], recordSearchParams, keySearchParams, feeRecord, provingKey, verifyingKey, privateKey, offlineQuery);
    }
    /**
     * Verify a proof of execution from an offline execution
     *
     * @param {executionResponse} executionResponse
     * @returns {boolean} True if the proof is valid, false otherwise
     */
    verifyExecution(executionResponse) {
        try {
            const execution = executionResponse.getExecution();
            const function_id = executionResponse.getFunctionId();
            const program = executionResponse.getProgram();
            const verifyingKey = executionResponse.getVerifyingKey();
            return verifyFunctionExecution(execution, verifyingKey, program, function_id);
        }
        catch (e) {
            console.warn("The execution was not found in the response, cannot verify the execution");
            return false;
        }
    }
    /**
     * Create a program object from a program's source code
     *
     * @param {string} program Program source code
     * @returns {Program | Error} The program object
     */
    createProgramFromSource(program) {
        return Program.fromString(program);
    }
    /**
     * Get the credits program object
     *
     * @returns {Program} The credits program object
     */
    creditsProgram() {
        return Program.getCreditsProgram();
    }
    /**
     * Verify a program is valid
     *
     * @param {string} program The program source code
     */
    verifyProgram(program) {
        try {
            Program.fromString(program);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    // Internal utility function for getting a credits.aleo record
    async getCreditsRecord(amount, nonces, record, params) {
        try {
            return record instanceof RecordPlaintext ? record : RecordPlaintext.fromString(record);
        }
        catch (e) {
            try {
                const recordProvider = this.recordProvider;
                return (await recordProvider.findCreditsRecord(amount, true, nonces, params));
            }
            catch (e) {
                throw logAndThrow(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
            }
        }
    }
}
// Ensure the transfer type requires an amount record
function requiresAmountRecord(transferType) {
    return PRIVATE_TRANSFER_TYPES.has(transferType);
}
// Validate the transfer type
function validateTransferType(transferType) {
    return VALID_TRANSFER_TYPES.has(transferType) ? transferType :
        logAndThrow(`Invalid transfer type '${transferType}'. Valid transfer types are 'private', 'privateToPublic', 'public', and 'publicToPrivate'.`);
}

const KEY_STORE = "https://testnet3.parameters.aleo.org/";
const CREDITS_PROGRAM_KEYS = {
    bond_public: {
        prover: KEY_STORE + "bond_public.prover.ff75d2e",
        verifier: "bond_public.verifier.d3cfe73",
        verifyingKey: "verifier1qygqqqqqqqqqqqzl9uqqqqqqqqq9stcqqqqqqqqqxa4sqqqqqqqqqyuwqqqqqqqqqpdyqqqqqqqqqqqvqqqqqqqqqqqx9lfqwmck43wt597p8xn68dh8l9setmmtk0ev35tgzkzm3j0j4tgu2s9kdu5w9m7g4dkglj28wayp2njn9qkuygpmcf9j7qc32aafepe5d9tdqyrq9ju2e8mlhkq8tucdh30rxysfl9h7d9jusmjhjcwgpuh0hhlspvtuv98n453apnqceupv2tc26wwx9mjl7m8j0urgax42xzrc9sltd62pfjgnw7vxh36vqxzajv5tyer6hpld0fr75jah48gaqpnexurtrag0azpcpep4lyxeyt4jytug2u7urfrp8rjh5wlkqqz7htzt8fdnthyngd5eqqfc6q0d6zw8lwlyr3hgqkjmkshmw5trm2tqg7euqav6r2vssqm9ut7ecjqq2fqs3k8mjp769qv5r2q52hcre66ymggtva7ty32lqpnrgrhgsc78g7qc00y5z6m626umkhqmz8sp0s4jz6qrvc6s47sycncq6ryltq2tmfxkz22e0g79cy4dzcnu5rwjkl4x3f27gavm7gug50tqnkwqrrjd430j9n8rrg78lpqfye8drxcnd2lxdry9nza8vfg4v3jmnmcdw55pu4kahfrawe4guvaqx26hqxhesqzxe343fjyz7vajn6prhg0jwzjtjh75v5wtp3h2knnvtshzae2uxel720fxg0vyfvnncsnxdqrqjc8aw8avq9kucsvauju4d0ke989s7v55ha0nh3dvdd9rct56pvg87txnhre3qvwmw6acf6t4x5q2al4gwwpqjhsezx6zmth0qeene0v3prwuh8a56r7qafhnyd98f8lx7xv4v48q7q7fd2373ag4fz5pmslx7v5hmpreqrdyj5h6we0kd24wk80f8sq44exsed3egstrn409cwzs9ph8563nh7vy6pcjnqxqrkzqvsa860spwjjf78hyful7zk2l3e9s4u4l0hqdyt547qxz3xamy5gkmd",
    },
    claim_unbond_public: {
        prover: KEY_STORE + "claim_unbond_public.prover.4c492b0",
        verifier: "claim_unbond_public.verifier.3793e4c",
        verifyingKey: "verifier1qygqqqqqqqqqqq8lycqqqqqqqqq02fsqqqqqqqqq849sqqqqqqqqpe26qqqqqqqqqzfnwqqqqqqqqqqvqqqqqqqqqqqgyhv4exh3e2g4f3ek5hymm8ah5h5hdp8v0j52dsksskad9wsryetk3qcr5um8t4nnpnqvhlsk5vcpea7w8uca2pum92jh2has0ag2gq24up0qr7p5z34jzrmtjx2583vkffyywmnatjs5t05x4yyc534cpsutfr4jaxqc9dlmxfw7a5tl4nl9q9qvweaver0q04pfl65w5wuyaadlzjhkkrrjaskg86tmkqy8s8vug7dyjnpe55y5ju8eag63p49ufdyguxdw2fwt46nwer74m3xmv9z6jhgslfwjre4fwctkppytsqrwmlf5szn9ckj2r86sa7azq0ly9atfjeee3f2f3n8s3rkrzezpqmcrt5lv3xlmymgspyj2vn7ytgqj97aula7tuxfrcsk787shhdjyxdvepspp7f4jaxuunzeuw58kdwupfdn8wj89grv5pk5qmxap9xgqxwwf08k98xnkdrp3n4jme0ur5604xp2q9fxlc0aw47vwfcurtsp9nv0rajv4lmune4mx8h39jvkcpv4fnngk3me5d6vds4m5xe6vuqlz55gnzue7fyyt0vzuwsg8f2ztepupry8g32ee48gmj2lldg96qp5xxcjxetgrq8muj4n7w3kv56spy3zhw8xr7ngd4u6l20pk4yvlsamu3y7nr4na246qqnjszlz6jq0922q8dsefkf7cpz8tc0fv4t2uk6y7r8wy5vtmah2y80al3vmc3kma70p4utwf40mc7x33y66zsgq94e09r5mmj5us835tz95w5r8eqz335lz8rac72d4jzxg0c40nmskvl236nz9dysg6uxp80yugx7cqckstk9f79ha0s6k8nftlmqds3za97648k2usw7xnyf9echpy3lsdsaatleyt5w5z2qgqyrxlaxsgq3tytq4qhjrlfz2dz7kuy7dyr0u4q5p78ux8ylh8tcsau46jevm944a798",
    },
    fee_private: {
        prover: KEY_STORE + "fee_private.prover.43fab98",
        verifier: "fee_private.verifier.f3dfefc",
        verifyingKey: "verifier1qygqqqqqqqqqqq8rjvqqqqqqqqq00ycqqqqqqqqqusvszqqqqqqqpnf6qyqqqqqqqqcd6qqqqqqqqqqvqqqqqqqqqqq0plfjy36deglp5xr0lk3rccawpqgztrnjusxnlkc8hz6879me8ty8y7rxzc3qqafadrmvz0v2aluqjwezzwkmj3q9vmr0xgk3arehjhppu7scsw6h4nj08z7fswhyq739ypuh67ff0f0sg8787aq4w80gqrn8e5kduw8h002rkjrw907zqxawqu7qmumx5zayg7k55rdzn05eg5sl8swr7fveuhud3gmf9xjsqzd9x9az5ls4s8cwjgc5lmvkhphy67q0g7qwzee7hyavg335j25mllnywrtjcwfejt55qxag7wvggqtmtc3al0gy6q83hql4wagk37e200592az7n525s80c4xwr92jr8dt40t3fyjxzszrc9umk95psswq82kkg25sh25s3mw5z3xt9qy2ftm8ec4a8l8rwfuxfujjrxxnhmrqs4wsunec3ukd4mur4fkj8enqqqv9n37e5fyag7e33rxsyp63u5rfs8hn26slsmdaqzvp2flcz506r0hqncdtt07nhulltlh5wyq4gpxsln5td2v0treu7t8wanhq6yv8hswxla7cf3w8nv4p233gz0ry9n7sj2uduredwtykw2ec3fs8fqrjkz8agg2xj8t9wden6spzdfcl7jlw4rgzv4hjqvh4cw40yhh8udv5g6vd0jhhfmqevezq0zs4x2q2m7u0hq9mkvulj950t9a5tcm6suycdlaky8t568jevkn3tf9uu5laevjumvahk4cxjxam85kq0l5qrycnmdzgvm7hr8cvl8a7qzcmjkwh48krtxtduhcfn7hvt752slm0nvth0yf35jugxg7ah2kw5emcq4mk962eypxyvwahf4k5ql8376l5za4zvv2p7jzgkjjs4lc60nv3czmdmmc0qn5mwnlnaxmwazs3qzfea0z0sn3nflp8v2lwlczljxre975fnvw3vfyrrjze4wuxtkjg7j37fph",
    },
    fee_public: {
        prover: KEY_STORE + "fee_public.prover.634f153",
        verifier: "fee_public.verifier.09eeb4f",
        verifyingKey: "verifier1qygqqqqqqqqqqqrcxyqqqqqqqqq8yvgqqqqqqqqqndesqqqqqqqqpg56qqqqqqqqqqhyyqqqqqqqqqqvqqqqqqqqqqq9a3p0z8q2qzsgq6lsd3zeh3tvezv0d2wg9tykutk9s7dat8uyamgxv54vv5le5slhta92cs08905qy0mgfdx0r7hzc7ec4qn8wmkx2cvtrwggad5h898kkp20eheukemkhj6g37flhpmxq9hpk9q2kfcsr58ufzupqpgfthzxsrn0554ttqckrgfwjfnvpfqhy4evahxkzahkf85pqt0es3j5jc2kzpkcu4ausrm4k53evjtuy3tzc3jgwl7y5t79j0ddhprs6ls9x0qpvqggvkffjg0psvjrmf2rsw5xrdnmqxlx5qru82dsavaka5kfsvxgyrzdf4tzceghyeqpk55308pkc0sg63sgwt8fywksccjdkkrqkh00kgraeuq97zsydp9z6pagtqmaply94dacmk7qkgg5jt36exjxcjdckjgswc5agg9xd4lqmpxxmtur7d7ecvvpg5rg4mzlf65hlpeynczqwdgrdekx7m3n4ljumgezxyzq7h9wmnrqfawayl5gns8gv2jaucwc9qmcq7pj6kvddw8dgpdf0rh66a6erzj9fmupu8ulc2x64092k5sfdm6rlaktdv8fscn8wlct0p9xahl2qqnxsw3tfzms5xplll4xamrlhtjm2xfsqmx62er2lmmzn6wk8788hcpg7uetlrufwlvmapeh00h9aqql6ggsknvwt45wjmfkky7z5ukly3dpjqvqt3yl839d8flcx6kpf5vqvdm57kqdwjazcmfn4ae87yqg08dlw805prfrfjvlyff3kq09z2yxc0pcaqalj7r4e6lygruk2ezpkfjlslyjtek6rtgvfwavqa5pmp6jgmr8xzu5dk0lcmfgm0plw8jkwt60pz2scpuh78k7f4dlfp7grjpn3xtdphhsn0k8rpfwqq3qr6huef2asc990ragxknla7kdl76xr2g2vl8pnql3f58wgcptked7rgeah8",
    },
    inclusion: {
        prover: KEY_STORE + "inclusion.prover.cd85cc5",
        verifier: "inclusion.verifier.e6f3add",
        verifyingKey: "verifier1qyyqqqqqqqqqqqzq7qqsqqqqqqq0huqpqqqqqqqqjvksgqqqqqqqqnypqgqqqqqqqzk8sqcqqqqqqqqvqqqqqqqqqqqxsh33gk03qelqrvy0g5m2km5vfhs6flwsutadvdl3nd82a3xqunx8pgaccs2yh654tpnanywulgvpvfxuma59ufttju8mvnpmuhg720p6fawv4ynhe75vfhn3te00saqpd5kpgxw59gf4r3ng3z0hr49gpwlwgkac7zlqk7cne5xh33m96qep9xeu2nf68dye57yqrnqgtaa2vk3ldcpurjn3s4pavzde8cehsrqn57qm2ewew3t4g6css5qzgfywdkkrx0rmz5u68cxvrwaksjd4s2exerl3u7cae58tc383yzd5tqxk66xqldl3ch8ymq73jhufwfcp4r8vcynmjenzt355a3qnejfndw7v5sn9a63wrd86rczgrp8wsuqsth7346q3qgaddsj6ln92233jjvke2krn809qvt8ev940hfclr5etza54055m8upn5jhg224v27cqamjy5lv3qm5nyc9asy0tqz0xsgmkuyp75t2qgv3h9s4av3u5tpmf8qkf7k7gp8rjlf67uncphscspvlmku59mgn4cqlxqqz3qdsyycs2my3emuyj9vnzt0464rfgnnmxwnw4kkqe50f764fjauj73kqcsxzn5mecv507xnetxvhfkt79r6hfvf6nzl735xtfp4r7uxlns3dazwj9mgl4fayzv0nqprh80ydqtq9tl6ffcmav2mlsky8tdrunewu3z8a2qg5wfhxz4j0xsqzfsr50ts63g0wysvnkt4rd6equa0r6fsqhrsjft0qy4jnstawrmnj28llqfgemj868y6aaw5rjftgp5vezg7r2c4q5zeupt4gghwand0jeyv5qfnxtnzh7wflxh7tdd0q6zh2fy635xhmllux8hk946t3kzenmc0355mz309gfachp2verz2qaepxsrj63nr54uga9eh2xcgp85v90dellhsvyx73m2w2qyed52svs62ysg7e3ag",
    },
    join: {
        prover: KEY_STORE + "join.prover.1a76fe8",
        verifier: "join.verifier.4f1701b",
        verifyingKey: "verifier1qygqqqqqqqqqqqz2cvqqqqqqqqqx0scqqqqqqqqqc42qzqqqqqqqpvmfqyqqqqqqqquzwqgqqqqqqqqvqqqqqqqqqqqpz6knqjfm77py0mpx68rmc6yavzrjpn3vdn5rmhum6u47fxt3j7auv5mk8epjx0hsa7nfm4llzwqqj84x9cnerm5gach0nzfy0jsvfrylvld5ffe8g63nhw5qng68rs6yrlzrc5229ezc8j4n4y0f2hrqqmdphh3mpglur7evq52n6mx9nls064fpn8wr3vqz75vextjhjmpvcrgs8har5txjnh9tj8lmlusns8nklkw8dh8nc8sv0llh4cgw95l3m7mwugu5nfrrlmyccnmrues4wl0hdfwsq8wvn60y2hl036g3aqzh5cn6n2366fy4hawjn22mj86w2w7twq80pdrea6svl7uq5zyh9nz4qgd72tql95n2xx0zh3wcjyqca5wzv4276exszaunpjduuvjmture49av40ve03akc9qw709wuf9a8hhpwlwwz8acf2z5ngk2d95qzfqhkmllqx4lnupyevkn8zthgu54x55t4cqm7uvmmnu3vtvkmsr4tldemm26shwk8ux27v6lmxkqppuesjj5d3m7x5rsg7yn8cg6hkat6fy8u8zj3n0z26ehqvmq8x2fadtw5jt6pxxfp3cm40ak7x9yqym5qrwjzpr7xwr4t6pjn5ca9g02hnuyvxd9jqpv70a7w05mqatnyzhnfl462xmsehgcwczjkrzz2qxk3wa0elrnvnh9qlz3cc2g8xyag9yrds0jepsvskl55zqtntp6qvkj9nkmlercd95j8g9xdgxv0sq0y6gq32ng5r9zcs4wt3vryhldxtr9epyz5vnnx4mf2lhv4r56mftaugjemxezpjcv9enr259tf7qq66a7ngsc3y0a5jlm8jg2rnd9c38ny2m5egl7ssx62zcscztkmjqpkvta2za4ym5jkatgzd2zspfcrc7gesjxjgcvhsua3jpyzpdan6mestyqsx5eatkmzv9zmpwkur3c34sjzc",
    },
    split: {
        prover: KEY_STORE + "split.prover.e6d12b9",
        verifier: "split.verifier.2f9733d",
        verifyingKey: "verifier1qygqqqqqqqqqqqpehuqqqqqqqqq930cqqqqqqqqq295qzqqqqqqqqyyyqyqqqqqqqzjjvqgqqqqqqqqvqqqqqqqqqqqyjhdhawnd33kv88ehql385slkd7lyr46jnf7yathmnxnr7at2j6u4nfkkvryujwt8rvhdfpuw94qq8e7sp33sjtyz53q89k85ttcg2cvadvuadeuq5xn4hgkmvm3qj93er0t2pjpd2p4kd3zy2gqmqd5qpfzdk973253ufzafqwd9879c7wpdv500a4xhetxkareamyl2qqzdd5hxl94vnmrkluzx0te32rkusqs20xswldqdgekfh6p25yxjhls20k59lsfn9az8jak9lr6r745ujsq0jq9fvugqyqchuca8xq6stq0svvu7e4xguc84t3s72erg4ve2z3nsr3jqv6jtala9j3xf5msksupprwwxkwwl58pv2hmr4g5h4xqym3nj6ax7ujx70np7egc4nw0w3j02m34eq00gssjq0pf9xfltxtef29crye3sul45kkawnrl6uzvquszlgltwtgx2xjlehgh0xpdm68dyjev9qxsleetpc33mns5jakrmqqryk8qgmnc56dzgcwm99eccq6c93576s946jztmuvgp8522y00jpck54wlcg3me44sk8usehsnjgm85zmypjsf7nlp06na927dtqp7u45jnd3em0n9h0wgtgvwh7lyhq4guwdfxws8mswwzfr5fjdtv0smjeq3r58v03amrhgr2ex4h7q8wapp8h5ug8vh0fxkt6yp3l2mas3l0jmmpedy9vx4lnxmjwn8t4wxyrdnnr54jxmp0wyu3sf6wwkqa6r2g2u9qu5km92fjnckme07mrxghuxh9ktpj9cvaf08sccdtdwjsnkyt9qu2x5ft27tkrskudrqpyr63x640xlk9wqpmy3edx58wxwzesmx22v62y6lshjv3wur83jlmwm74qqpd34ewmrk7eg0jfp7cretx5jwfv5c904v9qazfyluh5fpdczgx9fluayuukfwnqjq8tdwx3shuy5",
    },
    transfer_private: {
        prover: KEY_STORE + "transfer_private.prover.2b487c0",
        verifier: "transfer_private.verifier.3a3cbba",
        verifyingKey: "verifier1qygqqqqqqqqqqqqvccqqqqqqqqqz43sqqqqqqqqq7jqqzqqqqqqqpj4vqyqqqqqqqq0zuqgqqqqqqqqvqqqqqqqqqqqyvnz4pl9kjr0ks3dtkz67gw8tyqzs3sxskt8xg6keqrrqk9nj3e39kg65lzz5sd5tug2ecrpmfg5peseqmv709nry8up96qwsuvpp8684njpe4qunfhf7ywc0a7lck9rdlfcred8krn60lgztx4wlrlmspnnkwe9gmqk07tt5lj3wxcpucpshz7ec6w5mqvspprmu88lr9tr9e7a9fqdye0jdajq46pt35hdjsruamruf6v73fu68hv5fcsndmfq3c65yjrmljfg3343vj8cca2js2gumrks9eepm3d7g02jw0se9eqpaj86kpscxu4vuvw7jedgt2c0l4fk5zqwdu3vfhrazjwedl5d0n9w75ky0924qjjzg3c04dw7p8uqxqnuph6d3d935zqavxtte336jmnpk0hkjn80cejqfljl7w6jtnl3tedhtdk4cx207c7lud9xagzcp760x47h3hrw68syru4rnr3zgy99wcpnglpjvndzrjpc3z8c53xyqx0jh8cnt6gn92fgqu8a5huespxgnckqgttq8aa7xngxt9f5lpq2zgakfhtfvhlcy66k3depln3x67ck2m9t0fvnetjygj6h2er2fqqwcf2ghjp5fvq4e68635ql0lv5uv4c82575dcv87a0y8745g6gvjenh49zppsekc82dect9ggp3aqxqnc73dmd38pe4x7v9wwv6namfe7337tczyfz47dyxxzy8fslktv47yn8r87n0nap5qlc9gzgd2yq8m6zj0ulzgaqls2dq2atkfzxu5rjguvcjxnmn7hr8uxgxuzrwtmcftz4emn24vpq5pcwxf29a7w5p80e7f2tv7ags5k0pj9fghaklzm5xrakpsk3gv4xzvzqj6u2denjw60q777r5889xqrvchhtac4xspue4mncvgerscq4dslzkt4mg4zuv6t6gahcvnm2p6r02ns62xsdexs8jxt",
    },
    transfer_private_to_public: {
        prover: KEY_STORE + "transfer_private_to_public.prover.1ff64cb",
        verifier: "transfer_private_to_public.verifier.d5b60de",
        verifyingKey: "verifier1qygqqqqqqqqqqqrwjvqqqqqqqqqgpycqqqqqqqqquvvqzqqqqqqqqceuqyqqqqqqqqyd6qqqqqqqqqqvqqqqqqqqqqqr8z97pzqh2lxcc4tasdu784svuk6lv62sj78flptnzqks3hyu42ymryngdzr2mw6j4nxm4cmx8tgqnfzdkccekds6nhs4c7t2hf84d38jkuufdrf43ls4zm9htqarx9mv3gswcxp74kelgy36yhpsrfkgzdr8vy8580sulvaw36pxjjv0j543rml679z305kt2ju3wzarmsukzkfp56qnc0pjuptzajkes95uspd0uz3fd9fu5vmxwfwq9cj5qh0yjq398h729yygdm0fzkrl9g6faevalks3yc7xl3le38k77t3exqqnn82yyjpunpn763s8hkaguvn67jehqcvt8tvhql8skpesm9tm2hgeryk934h8c8cdcgynjq5cj2qer7kkjc2rrmg5j6agac0ya88up0sl2skxsvkw0rgxlgxjtjqc4g8c3xssq2sk6e2dufvc480rj8vqcrhtqsjqdkzq3nanlvngrjxchnzwfywwjphj5jeza2lyynrk5awz8v6jtwgxu2fs6uqrykz5lz6qpt2dfs670clhjpagxny40nmgeqtf9w8hu4v7yjpgwpv89v05u2ahdryu4538augkjhdx3hvfahwuszd8zyqmcxhrcq039hcrkd5qgadhj257vvrf27dwu64kl0j237efzvt5d360umxw3xk6tej5cxv9zqxqzc7ryqndhttaw5act9kwt8kvxtdjnzy99q8gzmg2429f94h6csrqejzc4n40xjcsdwn98hdekyqzytrh35w6t3r5d86kqt897kv5mldx9w06h4rldk734hvn096gt7e4smleja7canyfpv798cksshgq7hkyt6elvzp3rpj9nd84ykt9lzgjsswn4y8934ay3575u3sx7mkeuca0zsere2q0jmlsl6w6v2qcq424uhnmqn9q5vw22jgy94pry2junps40ug867d79h2zvd0n02nmlz05hd",
    },
    transfer_public: {
        prover: KEY_STORE + "transfer_public.prover.a74565e",
        verifier: "transfer_public.verifier.a4c2906",
        verifyingKey: "verifier1qygqqqqqqqqqqqq79uqqqqqqqqqp2tcqqqqqqqqqwd4qqqqqqqqqp5ydqqqqqqqqqqvyqqqqqqqqqqqvqqqqqqqqqqqre7drur40rst43dq9at346py7hkmrhexarf59f2tjt4stlsdj5uwrgnrkjjej7jf3djk2w4njtxcq0mezac793craujm8mr7wutcqtu2aday5g03wl0cu2572fsrtpyjhdyqlh0447z7dshlkhksjsusgp4ezrvc0n64fwetfmml3kvfg7n03w2e602sl7et4cpw98hgpzxwzrmzu8r3x77v49njysy2lp55xsqh6t5qjvhyl5a7nzy3e73y7dzvvs9p450u0s8g84prqnrk6jeah89c6882uzqdvxgzcedfmsc43uq99n3ycrjh70ys8n02pyvdvzmu7z608desdd5yw9dc8v3ddrdddmrzz2pupe09yn9esy25cfzmd0wqcgjdxm4dvlt2t6k66lw8e9ccj49qj2ahpht62kh7p56xpvpekenq2arng2t55mwxe59mqpkp6a0yqlwt7tdf98rt3kqlr9tdtq6hua3wrka0mqzhva4nhucxn9u4w92mly69jy2c7cqm5ftnk3m0qxy9spaxwfz0xkqd947yvf2zh8h4y59fltxdpeu4utpv9zw0cr7ad9d462qxyc2f05lezw6dwhcmep942qqv38lp3x9efestt5pk8rplvmrk0zz9zel48l8h9ldfzyd8zyr7knze92cdyanez6k7q5fu6tnw9wqrywjnhevaujz20xn0h3n47g85zs6ejfh7z8jt9qjesqgmdymvcxlceudkdsl49t5r69c4mg7hfwyq88z7zn0efda8fdjmhz8aaq24q34g2ekdzr5w9em3cev2ktxtmupqwltu0nh3fjzm04cy3cgnqlnqq0chzq4rs2dmfjwryxrxxgjtdcsnn9fpwykkxwfuervtznu3lmvhhpdflgwgm0xklu6c0xsxt9dfcp29w2nz6zkjetz7cqremg68eqxq86rn082czp50ldw9qkq6w3p9xxg4hrg",
    },
    transfer_public_to_private: {
        prover: KEY_STORE + "transfer_public_to_private.prover.1bcddf9",
        verifier: "transfer_public_to_private.verifier.b094554",
        verifyingKey: "verifier1qygqqqqqqqqqqqrhvqqqqqqqqqq8kcqqqqqqqqqqu0xsqqqqqqqqqw0kqqqqqqqqqreg7qqqqqqqqqqvqqqqqqqqqqqta360tn6dhv5z559ejfahwq88lxtd498py5p3vw5u3rwtfvdzpxq7fuqdahsrennq80g8yc6wqjyq8ahdv3jzry0mxceed0jr2cd0wye3e7782pg3phsu8h7hcapfgdghcgg2ykfc2682xefhsp3plqnqp692097k4ja82ecc2descl4d6csug04cz2j9a5pk3djx6xde2ghgq7uqvuhsg47ksueeetvc7mh2qpvqjmph9eekp5waqunkeea9vkvzyl8culmn5t7l9ke3r7uz8v5r8njjdkug6va9vy6axx9aq2kxaqdd9ll2m3j7qg7eyq3k2pnhq7gx2kv8vm3yf5pyqtywt2hvur5uv45y5st53qh970dktd3k709d9sqwv0d6qaksxjcp2cxu282hcewhy66vfs5kp35e6k4shdmjzmglyqqcsnupv8xwdr3596qypzshnuuq8rpm8pyjwtws63wsazqt8tlqhkkxucf0zjc384wvv2jemdnjwd6hn9745h8qc4kqp0rzs9wkx0hcp22xzuyyk7gpsc9ahw7pdenpje3etp37lfrcuntehl8wm2eudrh0j04szjzrv0n3r2gv04mgau5ysqtdcddq44xtt6t6f08c9zuhqukk8zy75jru0exufnh74u97d4xwe005ug7ywmcnyz8u6nvdav2xxqqzpg0luhghl8xu7g0cjgxse0lnqqedc7cc47nc048h2t44gedjq7f49ghajc9gwclp962v4q2855qvgdtkmr29cpwwq8vghlcjv0g6k0a0xa8yrmmnd5l7umnuqcd4x9rcejc3mkjgpw8y6mue2n5tx9cpahnw37yey5k38j98dnr9jss00420jvk7nh59hul7ef69n8ktcltl8f0t93rya5y8d2cspyjp6c7crvg2d4m37z78dualsqr9u7vtge07psdtl4l9785fxl3wgf9u277puvgvuq",
    },
    unbond_public: {
        prover: KEY_STORE + "unbond_public.prover.78b2191",
        verifier: "unbond_public.verifier.96c3590",
        verifyingKey: "verifier1qygqqqqqqqqqqqp89yqqqqqqqqqp62gqqqqqqqqq892qqqqqqqqqqym2qqqqqqqqqparjqqqqqqqqqqvqqqqqqqqqqqp9uker5608hsejeh46lk307z2ewatecukttkp7elhurugmwqay3ypevdjjt6ly68e9eyt2cnx7dcqrrf24kwmmy5ptlpyy72r5ul2lynras4lluy7ke6spzjx97m2qvjy3jhsdk8tpkwj3vqf37hcncjcqm5mrvp4v8txatw8hhtrklu0pjgx9p39jvvjxsqghf8rxm8edyacw3h8g7mqz8u8acay65tskf42qz5sqfvpfvg9ycnw3mp7jqnv80dnmev9k788aycnx9ufa09qfzjnxwnr6503ckc8465welwq7vxqlqyuezzshvq3gfpvdnqgrsda7kv88sq7nqpttlyqczrmsf6xln80ejcwshagevykxjc09numhdc4r7qlme5zlrjru7lyexcxq75qvtpqhkkz0zmfmm9paddlrk88xcctmhdun6rt0rzkdxx0fdgughvxlmyq32ct8s0k0qlf3rwlggvhvsw4ekl683ls9la7lcga87ereutr34fke6qzdkxz94rqzrl2msyhax9grx2t5jtkfenxsudq6mfjv0uhtxycalyk2k6c4hwdq5z33x4kcgns2tsx5hstvv6pp9phv0cedf4ysqgavdjlnx2g4tvw9wmmz7ghmm03jkutq568pxx7ahp7kjfe9ta2eas7qkj2r4ue0pwa5ft9k88r5qw32mymhz4p3cpg5g5v0z6kkukh9zxjzsdqnvglsdtj64u4dtu2epnnuckz3fgqw4mrn54nvvwv8zquwsz9jqp4zrux2xghqk6fh4y29vm3aq4v6kh4zmnwhuf0y249grf8u7xc6cu3rrz5ugpnzvawpyypmfnl58xgm0gq8m8zsn7uw436hhjwewyhwkva6trxdfxfr7rpn2qdu2yp2ulu7ezpr0meet8ht3zsqjyezyylcgrjttgphl0t2ckte6jwm6la7mlhz7ya8rancl44m9dpy798f9",
    },
    set_validator_state: {
        prover: KEY_STORE + "set_validator_state.prover.5ce19be",
        verifier: "set_validator_state.verifier.730d95b",
        verifyingKey: "verifier1qygqqqqqqqqqqqpehuqqqqqqqqq930cqqqqqqqqq295qzqqqqqqqqyyyqyqqqqqqqzjjvqgqqqqqqqqvqqqqqqqqqqqyjhdhawnd33kv88ehql385slkd7lyr46jnf7yathmnxnr7at2j6u4nfkkvryujwt8rvhdfpuw94qq8e7sp33sjtyz53q89k85ttcg2cvadvuadeuq5xn4hgkmvm3qj93er0t2pjpd2p4kd3zy2gqmqd5qpfzdk973253ufzafqwd9879c7wpdv500a4xhetxkareamyl2qqzdd5hxl94vnmrkluzx0te32rkusqs20xswldqdgekfh6p25yxjhls20k59lsfn9az8jak9lr6r745ujsq0jq9fvugqyqchuca8xq6stq0svvu7e4xguc84t3s72erg4ve2z3nsr3jqv6jtala9j3xf5msksupprwwxkwwl58pv2hmr4g5h4xqym3nj6ax7ujx70np7egc4nw0w3j02m34eq00gssjq0pf9xfltxtef29crye3sul45kkawnrl6uzvquszlgltwtgx2xjlehgh0xpdm68dyjev9qxsleetpc33mns5jakrmqqryk8qgmnc56dzgcwm99eccq6c93576s946jztmuvgp8522y00jpck54wlcg3me44sk8usehsnjgm85zmypjsf7nlp06na927dtqp7u45jnd3em0n9h0wgtgvwh7lyhq4guwdfxws8mswwzfr5fjdtv0smjeq3r58v03amrhgr2ex4h7q8wapp8h5ug8vh0fxkt6yp3l2mas3l0jmmpedy9vx4lnxmjwn8t4wxyrdnnr54jxmp0wyu3sf6wwkqa6r2g2u9qu5km92fjnckme07mrxghuxh9ktpj9cvaf08sccdtdwjsnkyt9qu2x5ft27tkrskudrqpyr63x640xlk9wqpmy3edx58wxwzesmx22v62y6lshjv3wur83jlmwm74qqpd34ewmrk7eg0jfp7cretx5jwfv5c904v9qazfyluh5fpdczgx9fluayuukfwnqjq8tdwx3shuy5"
    },
    unbond_delegator_as_validator: {
        prover: KEY_STORE + "unbond_delegator_as_validator.prover.115a86b",
        verifier: "unbond_delegator_as_validator.verifier.9585609",
        verifyingKey: "verifier1qygqqqqqqqqqqq8c9gqqqqqqqqqw72sqqqqqqqqqlfvqqqqqqqqqp2t0qqqqqqqqqqencqqqqqqqqqqvqqqqqqqqqqq0grv3rvp00lpr8rd0gvrlzmxfldeur8rd0rh2amsut4350grudguqrf59q2x4y9mvh27dptpllesqacgeq7er0s9xjrt87q9hqt8ntaxjycfmdxf5xqm749xegmh7vzx6d6pzmzesmhtlue58gapec39sp545htqgeff2a4ahtm8xlswh8yhwqax83yexvuwxfxrnjkueszuha2v8txhyzcg0umtgrqmg5gd2szf44v65920m8dmazcjpllt66l526k6khzsg3eunzqwtd3f9afp5lkaaey7dmltvwzkslm5x54gfcqtf2ma4uej82juvpnxz2e5u3n7a7e3668e42djfjewc5d6h5w7jrz8fmzw56u0nnujy48a0csta3vqz7zux0a3enz27y76zkm5wpppnaq69498k0n9dexftjt52ddtmh2nq34p8m2mt9n68drv2ndm7v75q6dwx5675ycapv7x45vvfhyywg0pq2hvk44mc0ry4czvemt8t7ayfnnksupl20rvmsmqrngaf8gyqza4pytae47wr8mv3r90qmesguclvxvdp7wz3ygyv4rxu0vhjf9lmmymyjcf64ampvtup3x5fst6cq8mgel7t9czxsfx53a35mpfmgdpr8hk3cj798y0fa8zf4a8cw9qu2xsp37vhnkwl25pjfy6lu7h6lqxj8dez7k8g4km3yfxnqjhvyh6279r92a6rdg2j9spuhrq2dyadxygytnc9jqxfh3jtaxzydtz57gqg564f43m5hlswpel98zlnz8lc5740srsd96fv5k0aqhku8xd0q6myj77h7m4n0we5mcxa24zt0rspl8602e3adu06j3h9e9tz8sdw5s005aw0e8y4mmhv3u5swhfl5yv4aarj45j5pg57htp42s80c3hcpzghmmnan73lw0lkjfgxff2989yhu2n0qakdvdqvelz473mhwlrlad3y5f"
    },
};
const PRIVATE_TRANSFER_TYPES = new Set([
    "transfer_private",
    "private",
    "transferPrivate",
    "transfer_private_to_public",
    "privateToPublic",
    "transferPrivateToPublic",
]);
const VALID_TRANSFER_TYPES = new Set([
    "transfer_private",
    "private",
    "transferPrivate",
    "transfer_private_to_public",
    "privateToPublic",
    "transferPrivateToPublic",
    "transfer_public",
    "public",
    "transferPublic",
    "transfer_public_to_private",
    "publicToPrivate",
    "transferPublicToPrivate",
]);
const PRIVATE_TRANSFER = new Set([
    "private",
    "transfer_private",
    "transferPrivate",
]);
const PRIVATE_TO_PUBLIC_TRANSFER = new Set([
    "private_to_public",
    "privateToPublic",
    "transfer_private_to_public",
    "transferPrivateToPublic",
]);
const PUBLIC_TRANSFER = new Set([
    "public",
    "transfer_public",
    "transferPublic",
]);
const PUBLIC_TO_PRIVATE_TRANSFER = new Set([
    "public_to_private",
    "publicToPrivate",
    "transfer_public_to_private",
    "transferPublicToPrivate",
]);
function logAndThrow(message) {
    console.error(message);
    throw message;
}
// @TODO: This function is no longer needed, remove it.
async function initializeWasm() {
    console.warn("initializeWasm is deprecated, you no longer need to use it");
}

export { Account, AleoKeyProvider, AleoKeyProviderParams, AleoNetworkClient, BlockHeightSearch, CREDITS_PROGRAM_KEYS, KEY_STORE, NetworkRecordProvider, PRIVATE_TO_PUBLIC_TRANSFER, PRIVATE_TRANSFER, PRIVATE_TRANSFER_TYPES, PUBLIC_TO_PRIVATE_TRANSFER, PUBLIC_TRANSFER, ProgramManager, VALID_TRANSFER_TYPES, createAleoWorker, initializeWasm, logAndThrow };
//# sourceMappingURL=index.js.map
